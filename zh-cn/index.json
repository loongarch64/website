[{"categories":[""],"content":"随着龙架构的 UEFI、内核及Grub的快速完善，在龙架构上启动系统已经完全标准化了，本文简要介绍一下使用 Grub 来进行网络启动的方法。\n服务器设置 制作引导程序 方式一 $ grub-mknetdir --net-directory /var/ftpd/ 已创建用于 loongarch64-efi 的网络引导目录。请配置您的 DHCP 服务器以指向 /var/ftpd/boot/grub/loongarch64-efi/core.efi 方式二 $ cat /tmp/start.cfg normal (tftp)/boot/grub/grub.cfg $ grub-mkimage -O loongarch64-efi -o /var/ftpd/grubnetboot.efi --prefix=\u0026quot;(tftp)/boot/grub\u0026quot; -c /tmp/start.cfg -v net tftp efinet http blocklist boot configfile linux reboot normal search cat progress lvm part_gpt part_msdos cpio ext2 fat hfs hfsplus iso9660 ntfs tar udf ufs1 ufs2 xfs zfs loopback newc btrfs help halt font loadenv memdisk msdospart terminal zfs zstd zfsinfo xzio 注：\n方式一生成的整个目录，如果服务器是非 LoongArch 机器，请将此目录完整复制到服务器的 tftp 根目录中。\n方式二生成的是一个独立文件，如果服务器是非 LoongArch 机器，只需要将此文件复制到服务器的 tftp 根目录中。\nDHCP、TFTP 服务 dnsmasq 集成了 DHCP 和 TFTP 功能，配置相对简单，大部分 Linux 发行版都可以直接安装。\ndnsmasq 配置参考：\n$ cat /etc/dnsmasq.conf server=114.114.114.114 interface=enp2s0 listen-address=::1,127.0.0.1,10.10.10.8 expand-hosts dhcp-range=set:lan,10.10.10.10,10.10.10.30,12h enable-tftp tftp-root=/var/ftpd #以下2行内容，分别对应方式一和方式二生成的引导程序，请根据制作方式选择其中一种 #dhcp-boot=/var/ftpd/boot/grub/loongarch64-efi/core.efi #dhcp-boot=/var/ftpd/grubnetboot.efi cache-size=1000 log-queries sudo systemctl restart dnsmasq\ngrub 配置 以 Loong Arch Linux 为例来说明网络启动配置，其它发行版，请参考对应的发行版说明文件。\n下载内核及initrd文件\n# mkdir /var/ftpd/boot/ # wget https://mirrors.wsyu.edu.cn/loongarch/archlinux/iso/latest/arch/boot/loong64/vmlinuz-linux # wget https://mirrors.wsyu.edu.cn/loongarch/archlinux/iso/latest/arch/boot/loong64/initramfs-linux.img grub.cfg 内容\n# mkdir -p /var/ftpd/boot/grub # cat /var/ftpd/boot/grub/grub.cfg set default=0 set timeout=10 set root=(tftp) menuentry 'PXE Install Archlinux'{ echo 'Loading Linux kernel...' linux /boot/vmlinuz-linux archiso_http_srv=http://mirrors.wsyu.edu.cn/loongarch/archlinux/latest/ archisobasedir=arch ip=dhcp net.ifnames=0 loglevel=7 echo 'Loading initrd...' initrd /boot/initramfs-linux.img } 从网络引导系统 龙架构电脑开机，按 F2 进入固件设置界面，打开 Http 协议及 PXE 支持，保存并重启。\n在 BIOS 的 Logo 显示界面，按 F12 ，选择从网络启动。\n","permalink":"/zh-cn/posts/pxe-grub/","series":null,"tags":["新闻"],"title":"网络启动之Grub篇"},{"categories":[""],"content":"2022 年上游社区的各项工作在积极推进中，截止到目前，可用于构建操作系统发行版的组件大部分已经进入上游，并且陆续出现一些基于上游社区的发行版。\n上游社区提交情况 今年进入上游社区的软件很多，比如内核、工具链、qemu等等，由于软件数量过多，不再一一进行列举，以下仅说明目前仍在积极向上游提交、审核中的关键组件情况：\nllvm/clang: 积极提交补丁中，预计 16 版本将直接支持 LoongArch\ngrub: 积极提交补丁中，预计 2.12 版本将直接支持 LoongArch\nrust: 已有部分模块进入上游，主分支依赖于 llvm 先支持\nHaskell/ghc: 积极提交补丁中，预计等 llvm 16 发布后可用\n\u0026hellip;\n上游社区发行版情况 Archlinux Archlinux 是首个提供安装光盘的上游发行版，首次对外发布版本为2021.07 ，后经过多次重构，先后又发布了 2022.03 、2022.09 等版本，从 2022.09 版本开始，上游用户态ABI趋于稳定，开始滚动升级，目前已经升级到 2022.12 版本。\n开发者： 武老师\n源码仓库： https://github.com/loongarchlinux\n仓库地址： https://mirrors.wsyu.edu.cn/loongarch/archlinux\n下载地址： https://mirrors.wsyu.edu.cn/loongarch/archlinux/iso/\n主要特性：\n 基于 v2.0 ABI 的新世界系统 滚动更新，组件和 Archlinux x86_64 保持一致，通常会晚于 x86_64 一个月左右。 提供 debuginfod 服务，运行 gdb 时自动从远程服务器下载 debug 包 提供 setup 中文 TUI 安装界面 不定期发布 snapshot iso 镜像，安装建议使用最新版本。 目前已有 xfce4、mate、lxde、lxqt、cinnamon 等桌面环境，其它桌面环境会陆续补充完整。 提供预安装的 qemu qcow2 体验镜像 ，用户名和密码均为 loongarch 增加 laur 仓库，提供 LoongArch 架构典型应用 完全清理了 python2 软件包 支持二进制翻译应用(有彩蛋)  CLFS CLFS 是 LoongArch 架构上游社区当之无愧的的第一个发行版，其他发行版都直接或间接地借助于 CLFS 完成了 bootstrap。\nCLFS 为 LoongArch 工具链、内核等重要基础组件提供了测试验证环境，并持续进行重构，为基础组件尽快推进上游提供了坚实的基础。\n开发者： 豹老师\n下载地址： https://github.com/sunhaiyong1978/CLFS-for-LoongArch/releases/tag/7.0\n主要特性：\n 基于 v2.0 ABI 的新世界系统 提供交叉编译工具链 提供启动系统包 提供基础系统包 提供图形登录管理器 提供LXDE桌面环境  Debian(开发中) 移植进度： https://wiki.debian.org/Ports/loong64\nFedora(开发中） 开发者： 豹老师\n源码仓库： https://github.com/fedora-remix-loongarch\n仓库地址： https://mirrors.wsyu.edu.cn/fedora/\n下载地址： https://github.com/fedora-remix-loongarch/releases-info/releases\n主要特性：\n 基于 v2.0 ABI 的新世界系统。 采用Fedora的rawhide仓库滚动更新，软件版本较新。 软件仓库中提供的可安装文件已超过5万个。 提供与Fedora主流架构相同的安装和使用方式。  Gentoo(官方发布) Gentoo 移植开始于2021年08月11日，是首个采用 ARCH=loong 的新世界发行版，也是首个由上游直接发布 LoongArch 架构的发行版。\n开发者： 白老师\n源码仓库： https://gitweb.gentoo.org/\n下载地址： https://www.gentoo.org/downloads/#loong\n主要特性：\n 基于 v2.0 ABI 的新世界系统 Gentoo 官方发布  Slackware 开发者： 史老师\n源码仓库： https://github.com/slackwarecn/slackware-loongarch64\n仓库地址： http://pkg.iloongarch.cn/slackwareloong/slackware64-current\n下载地址： http://pkg.iloongarch.cn/slackwareloong/iso\n主要特性：\n 基于 v2.0 ABI 的新世界系统。 目前已有 xfce4 桌面环境，其它桌面环境会陆续补充完整。  嵌入式和教学操作系统 除了上述通用的Linux发行版，一个完善的软件生态中还需要许多面向不同领域的嵌入式系统以及一些专门为了教学而生的教学操作系统，2022年社区在这方面也取得了较大的进展。\nmit xv6-loongarch xv6 是MIT开发的一个类Unix教学操作系统，与Linux或BSD不同，xv6非常简单，足以在一个学期内讲完，但仍包含Unix的重要概念和组织结构。xv6被全世界很多高校用于操作系统教学。\n开发者： 深圳大学罗老师\n仓库地址： https://github.com/skt-cpuos/xv6-loongarch-exp\n主要特性：\n 基于v2.0 ABI的新世界系统 仓库含OS代码、实验代码、实验指导书和PPT演示资料，可以直接用于操作系统教学  mit xv6-labs 本项目是xv6-labs-2021相关实验在LoongArch平台的参考实现。具体的实验设计参见xv6主页 的labs标签页。\n实现者： 邓老师\n仓库地址： https://github.com/Fan33oo/xv6-labs-loongarch\n主要特性：\n 完成utils，syscall，pgtbl，trap，cow，thread，mmap实验 net实验，pci设备支持，有待完善 lock实验，龙芯qemu还不支持多核 fs实验，龙芯qemu内存限制，有待完善  uCore uCore OS清华大学计算机系开发的教学操作系统。本项目基于ucore-thumips ，现移植到LoongArch 32。并成功跑通了所有的用户进程。\n开发者： 重庆大学陈老师\n仓库地址： https://github.com/cyyself/ucore-loongarch32\n实验指导书： https://cyyself.github.io/ucore_la32_docs\n主要特性：\n 基于v2.0 ABI的新世界系统 可运行在LoongArch开源Soc平台  成功跑通所有的用户进程 实验环境有Docker镜像支持，使用docker pull chenyy/la32r-env进行安装，在该容器编译  rCore rCore是清华教学操作系统的rust版本。2022年全国大学生操作系统大赛上北理工陈同学将其移植到LoongArch平台。\n开发者： 北理工陈老师\n仓库地址： https://github.com/Godones/rCoreloongArch\n主要特性：\n 基于v2.0 ABI的新世界系统 支持ch0-ch8实验 支持简易内核栈回溯 项目荣获2022年全国大学生操作系统大赛-功能挑战赛二等奖。  MaQueOS 本项目是用于兰州大学的教学操作系统，兰州大学相关团队为其编写了教材《MaQueOS：基于龙芯LoongArch架构的教学版操作系统》。\n开发者： 兰州大学周老师团队\n仓库地址： https://gitee.com/dslab-lzu/maqueos\n主要特性：\n 基于v2.0 ABI的新世界系统 项目有配套教材 实验丰富，12章实验涵盖内存管理、文件系统、设备管理等  Yocto Yocto是用于定制嵌入式Linux系统的主流工具之一。龙芯相关团队基本完成了yocto的LoongArch支持工作，可以在x86平台和LoongArch平台从零构建定制的Linux/LoongArch嵌入式系统，并生成相应的SDK。基础支持部分已经进入上游yocto社区。\n开发者： 龙芯团队\n参考仓库地址：\n https://github.com/foxsen/poky(openembedded 参考系统) + https://github.com/foxsen/meta-loongson(LoongArch相关BSP层) https://github.com/yoctoproject/poky  主要特性：\n 基于v2.0 ABI的新世界系统 基于上游开源软件构建  seL4 seL4是首个经过形式化验证的微内核，是经典的L4系列微内核的一种实现，具有安全、高性能、高可靠等特色。已在2022年移植到了LoongArch架构，并通过了其自带的所有测试。\n开发者： tyyteam 主仓库地址： https://github.com/tyyteam/la-seL4\n主要特性：\n 基于v2.0 ABI的新世界系统 陈老师重新整理 ，已向上游提PR  移植或使用了10个官方仓库 项目视频 ，通过了sel4test测试用例 项目文档  项目荣获2022年全国大学生操作系统大赛-功能挑战赛一等奖  其他进行中的工作 Fuchsia kernel zircon是Google fuchsia系统的微内核。基于PanQL 分离的zricon代码 ，龙芯相关同学完成了向LoongArch架构的初步移植。\n开发者： 徐老师 耿老师\n仓库地址： 代码完善后即将公开\n主要特性：\n 基于v2.0 ABI的新世界系统 目前进度：可以shell，支持简单的cd，ls等命令  NuttX NuttX是完全兼容Posix和ANSI标准的嵌入式实时系统，有着轻量级、定制化的特点，已被广泛应用在成熟的商业系统或软件中，如小米Vela系统、三星Tizen RT系统、px4飞行控制软件。\n开发者： 刘老师\n仓库地址： https://github.com/LA-NuttX\n主要特性：\n  基于v2.0 ABI的新世界系统\n  正在移植flat build模式的nsh64程序\n  计划移植kernel build模式\n  计划移植knsh64、smp64、net64程序\n ","permalink":"/zh-cn/posts/2022year/","series":null,"tags":["新闻"],"title":"2022年社区动态"},{"categories":["编程"],"content":"简单介绍编写 LoongArch 架构的汇编程序所需要的一些知识，并提供了相应的实验环境和示例链接。\nLoongArch 架构汇编快速入门 龙芯常用的汇编器是 GNU as 汇编器，as 的具体使用可以参见: Binutils 官方文档 。\n数据类型和常量 数据类型  所有 LoongArch 指令都是 32 位长的。 字节(byte) = 8 位(bit) 半字(half) = 2 个字节 字(word) = 4 个字节 双字(dword) = 8 个字节 注意，汇编里用 .long 定义的数据是 4 个字节  常量  数字直接输入，如：1234 单个字符用单引号，例如：\u0026lsquo;a\u0026rsquo; 字符串用双引号，例如：\u0026ldquo;hello world\u0026rdquo;  寄存器和ABI  LoongArch 下一共有 32 个通用定点寄存器 在汇编中，寄存器标志由 $ 符开头，寄存器表示可以有两种方式  直接使用该寄存器对应的编号，例如：从 $0 到 $31，浮点则是 $f0 到 $f31。 使用对应的寄存器名称，例如：$a0, $t1，详细含义参见 龙架构 ABI 文档 。   栈的走向是从高地址到低地址  龙架构ABI 二进制程序接口( Application Binary Interface )是为了实现二进制模块之间的交互引入的人为约定，包括寄存器使用、如何在子程序之间传递参数，数据类型，对齐，系统调用等内容。龙架构的 ABI 总体遵循 SysV ABI 框架，架构相关的约定参见 龙架构 ABI 文档 。\n程序结构 包括数据声明和程序代码，通常保存为后缀 .s 或者 .S 的文本文件。一般先是数据声明，后是代码段。\n数据声明  以汇编伪指令 .data 开始 声明程序用到的变量名字，并在内存中分配空间  代码  代码段以 .text 为开始标志 包括程序指令 程序入口为 main: 标签所在位置 程序结束时应该用 exit 系统调用（参见后文系统调用一节）  注释  一行中 # 字符之后的内容  一个 LoongArch 汇编程序模板 # 描述此程序名字和功能的注释 # Template.s # 汇编程序模板 .data # 本行之后是数据声明 数据申明 1 数据申明 2 ... .text # 指令在本行之后开始 .global main main: # 程序入口 指令 1 指令 2 ... 数据声明格式 声明的格式：\nname: storage_type\tvalue(s)\t变量名: 数据类型 变量值   创建给定类型、名字和值的变量，值是是该变量的初始值 注意：名字后面要跟英文冒号  例子：\nvar1:\t.word\t3\t# 声明一个 word 类型的变量 var1, 同时给其赋值为 3 array1:\t.byte\t'a','b'\t# 声明一个存储 2 个字符的数组 array1，并赋值 'a', 'b' array2:\t.space\t40\t# 为变量 array2 分配 40 字节（bytes) 未使用的连续空间，当然，对于这个变量 # 到底要存放什么类型的值， 最好事先声明注释下！  汇编伪指令 汇编伪指令 (directive) 是由 . 打头的一些特殊标记符，它指示汇编器做一些特定的动作，如前述介绍的 .word/.data 等。龙架构的汇编伪指令由 GNU as 汇编器支持的所有架构无关伪指令和它特有的伪指令组成。\n架构无关伪指令的详细情况，可以参见 as 伪指令文档 。常用的伪指令包括：\n .data/.text/.section 等，用于定义 elf 的 section （节）开始，把后续的代码或者数据放置到那个 elf 节 .global，把函数名或者变量名声明为全局变量，例如汇编程序的 main 要定义为 global，缺省的链接才会成功 .align n，定义 2^n 对齐 .if/.ifxx/.elseif/.else/.endif，条件编译控制 .macro，定义汇编宏代码块，可以带参数 .ascii/.asciz，定义字符串，后者以 0 结尾 .float/.double，定义单精度、双精度浮点 .include，包含另一个汇编源文件  后者目前仅有几个，可以从 binutils 源代码 gas/config/tc-loongarch.c 中的 loongarch_pseudo_table 看到，包括：\n .align n，约定按 2^n 对齐后续地址 .dword，定义 8 字节的双字 .word, 字 .half, 半字 .dtprelword, dwarf 调试信息用的一种重定位伪指令 .dtpreldword, dwarf 调试信息用的一种重定位伪指令  常用指令  Load/Store 访存指令，参见 龙架构存储指令  算术逻辑指令。参见 龙架构 ALU 指令  控制流指令。参见 龙架构控制指令   地址空间安排 普通汇编程序可以使用 gcc 工具链提供的缺省链接脚本，由编译器选择缺省的程序代码段、数据段装载地址。如果有特殊需要，可以使用 GNU ld 链接程序的链接脚本支持，灵活指定代码或者数据被装载的地址。\n代码案例和运行测试环境 参见这个 github 开源项目：loongarch-assembly 。\n","permalink":"/zh-cn/posts/20220809-loongarch-assembly/","series":null,"tags":["汇编"],"title":"LoongArch 汇编快速入门"},{"categories":["内核","kernel"],"content":"今天凌晨（当地时间6月3日晚），LoongArch CPU 的支持补丁被 Linus 合并进了主线内核，这意味着从 5.19 内核开始，用户空间 ABI 已经稳定。\n今天凌晨（当地时间6月3日晚），LoongArch CPU 的支持补丁被 Linus 合并进了主线内核，这意味着从 5.19 内核开始，用户空间 ABI 已经稳定。\n国外相关新闻： https://www.phoronix.com/scan.php?page=news_item\u0026amp;px=LoongArch-Merged-Linux-5.19\n到目前为止，工具链中的 binutils-2.38.50(开发版本)、gcc-12 已经进入上游，在内核此次合并代码之后，glibc 上游工作也可以顺利推进了，希望在 8 月份的 glibc-2.38 中能看到对 LoongArch 的支持。\n本次内核合并的代码并不完整，EFI、PCI子系统、IRQ 驱动程序部分需要继续完善，预计在 5.20 版本内核将获得完整支持。\n另外，基于最新(兼容)的上游代码，已经准备好了几种发行版，包括 CLFS、Gentoo、Archlinux，但需要您关注 Firmware 项目，以获得新固件。\n注：\n  新固件采用物理地址内核，目前 不能兼容现有 LoongArch 发行版\n  默认的 EFI 文件加载路径是 /EFI/BOOT/BOOTLOONGARCH64.EFI\n  社区发行版下载地址：\nCLFS: https://github.com/loongson/build-tools/releases/tag/2022.05.29\nGentoo: https://mirrors.163.com/gentoo/experimental/loong/stages/20220528/\nArchlinux: http://archlinux.oukan.online/2022.03/iso/\n","permalink":"/zh-cn/posts/loongarch-merged-linux/","series":null,"tags":["新闻"],"title":"LoongArch 架构支持合并到 Linux 5.19 内核"},{"categories":[""],"content":"2021年四季度，LoongArch 平台开发者手册开放更新中；基础软件、开发语言、系统软件继续稳步推进。\n开发者手册 LoongArch Processor SMBIOS Spec : 为上游 SMBIOS 规范增加 LoongArch 处理器部分，预计在 V3.6.0 版本将合并到上游。\n以上手册作为开发者必备的参考资料，同时也是指导工具链实现的规范，目前在社区开放讨论并持续更新中， https://github.com/loongson/LoongArch-Documentation\n基础软件 QEMU WANG Xuerui 提交的 LoongArch TCG host 支持补丁上游已合并。\nhttps://patchew.org/QEMU/20211221054105.178795-1-git@xen0n.name/\n开发语言 golang limeidan 和 liuxiaodong 提交的 golang/net 补丁上游已合并。\nhttps://github.com/golang/net/commit/d55c255bac037b8052cb2cb906e2a42ef152ff79\n系统软件 beetle-pce-fast-libretro fyl 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/libretro/beetle-pce-fast-libretro/commit/eb57e0c21f082de9f0ba86f26b3c716a2ed18b14\nbenchmark huajingyun 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/google/benchmark/commit/f90215f1cc2c22d32d96e903ea031278681e4adb\nchromium Zhao Jiazhong 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/chromium/chromium/commit/8f1041be06763964d54b6bfac7faa751569b4a48\nffmpeg guxiwei、yin shiyou、Hao Chen、Jin Bo 等人提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/FFmpeg/FFmpeg/commit/024e934480a34ff534020f1617c94a7212f88a0f https://github.com/FFmpeg/FFmpeg/commit/07f8f78a5fb8b6a28f7b9d79fae6e411a17114ee https://github.com/FFmpeg/FFmpeg/commit/1ccc45896096b39b9a0d5650618d384df30d15e4 https://github.com/FFmpeg/FFmpeg/commit/2fd914e079645ad08a4068b46c161f4a01b5b996 https://github.com/FFmpeg/FFmpeg/commit/3f294ec8799390af0bfc6916c312e5b1e0035c10 https://github.com/FFmpeg/FFmpeg/commit/555b850bd56c87007c6b7b02dbb1e474e9911dfa https://github.com/FFmpeg/FFmpeg/commit/5d58355bf1a7bd07b0f08bf1f90f4aba8b89d727 https://github.com/FFmpeg/FFmpeg/commit/5ff58b77bb1f44a2074967cb0e0b7db3b437df10 https://github.com/FFmpeg/FFmpeg/commit/6038a9eb92b2daac907c941dbb245ed43c350501 https://github.com/FFmpeg/FFmpeg/commit/72bcbe216ef3d47498392ed2bada83994cd9fc86 https://github.com/FFmpeg/FFmpeg/commit/8ca7d474c19f856b28fa588e040b23b1a58368ed https://github.com/FFmpeg/FFmpeg/commit/8ca7d474c19f856b28fa588e040b23b1a58368ed https://github.com/FFmpeg/FFmpeg/commit/9a840ffa176038d44e0197283590f891b2cf9eeb https://github.com/FFmpeg/FFmpeg/commit/afcb36b7e54727d533b45303b36fa0d13ce02797 https://github.com/FFmpeg/FFmpeg/commit/cba7c0267dad3963ff52f146012dd99fd5b55c2c https://github.com/FFmpeg/FFmpeg/commit/df46d7cb49ce301d83c1d20cfc4ef47390d47691 https://github.com/FFmpeg/FFmpeg/commit/fea299f8768adbbddcb5b26a34f622a8606945a6\nffmpeg 5.0 版本已经增加了 LoongArch 架构，参见 Changelog:\nhttps://git.ffmpeg.org/gitweb/ffmpeg.git/blob/refs/heads/release/5.0:/Changelog\njnr-constants shanjiantao 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/jnr/jnr-constants/commit/413ff6e502c86edda2ebae9f8689e2b9c462e743\njnr-constants 0.10.2 版本已经增加了 LoongArch 架构\nlibffcall https://git.savannah.gnu.org/gitweb/?p=libffcall.git;a=commit;h=600d713cd18f09a698f937ff6c2cead41036e3da\nlibunwind Tiezhu Yang、 Qing Zhang、 Jinyang He、 Youling Tang 等人提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/libunwind/libunwind/commit/c5f1d12c77dea6a60740730c675fc56b3c52b86a\nlibyuv Hao Chen 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/noiseless/libyuv/commit/2f87e9a7135b83656c86b3b23ba582e0dfeb7fbb https://github.com/noiseless/libyuv/commit/f8e2da48aed24a7b2608172aa5e59421f1f802d4 https://github.com/noiseless/libyuv/commit/dfe046d27255cff06fc4cfe42c6d373fd83bc2aa https://github.com/noiseless/libyuv/commit/de8ae8c679f5a42fb9f9f65318d6cb95112180d6 https://github.com/noiseless/libyuv/commit/51de1e16f20bb93468d7c538629b40ece8420b71\nNim wenghongquan 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/nim-lang/Nim/commit/742e9d65ad6b56387dc6bf9a2be1b95c510fd0c4\nNodeJS Shi Pujin 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/nodejs/node/commit/81e88f27b7199bafc9e26bb1def2d06bac2b9fad\nNumPy NumPy 1.22.0 版本已经支持 LoongArch 架构，参见 Release Notes:\nhttps://numpy.org/doc/stable/release/1.22.0-notes.html\node zhangna 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://bitbucket.org/odedevs/ode/commits/04f4c2d33f4abcb2970e8377d1a35e06c6ff3504\nOpenBLAS gxw 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/xianyi/OpenBLAS/commit/af0a69f355a086d70cc08ccda8bde7a48b3133c4\nOpenBLAS 0.3.18 版本已经支持 LoongArch 架构，参见 Release Notes:\nhttps://github.com/xianyi/OpenBLAS/releases/tag/v0.3.18\nOpenH264 jinboson、Lu Wang 等人提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/cisco/openh264/commit/a8094d85f5dd5ef112fbcfec2974e18fd0387c0b\npatchelf zhangwenlong 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/NixOS/patchelf/commit/a174cf3006baf31e0e9eaa62bc9adead93af63f7\npwsafe Yaling Fang 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/pwsafe/pwsafe/commit/faf1545c3c0327fb5e7c84502146014d1550cb50\npyroute2 zhangwenlong 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/svinota/pyroute2/commit/6fdae02ff0666c11e726166e296d67c75782587b\nstrace WANG Xuerui 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/strace/strace/commit/2bf68c3b08ba82f4f41035e58149c06d2421cbd6 https://github.com/strace/strace/commit/665f7bb525b2a800257af5d3d83b796e6cd9ddbe https://github.com/strace/strace/commit/819a2c5ff74e8fd957d36ae1e70cb87f02d2b9b6\nstringi liuxiang88 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/gagolews/stringi/commit/23b92c604c2bb48cc5b6a241e4875182c5889aeb\nsystemd Wu Xiaotian 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/systemd/systemd/commit/646b01121a9cf2009768af2dac080940b9803624 https://github.com/systemd/systemd/commit/ff6d286902b4330a07e0d4a141751344257ef0c1 https://github.com/systemd/systemd/commit/eebbd595f0de9505f4df3c3460ab36d46d8262f8 https://github.com/systemd/systemd/commit/89f60c217c3f095db8e530c63fcb761fd64dc2d4 https://github.com/systemd/systemd/commit/0444a6e4be6bdc4d57076609f182497ea79aa7b5\nsystemd 250 版本已经初步增加了 LoongArch 架构，参见 Release Notes:\nhttps://github.com/systemd/systemd/releases/tag/v250\ntilibs suntie 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/debrouxl/tilibs/commit/3447f6e786b377f2eb5c40cc840024098633a9e0\ntup Yaling Fang 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/gittup/tup/commit/324d0cd97b0d78566f19f0b30cb072eddeabd99d\nunarr liuxiang88 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/selmf/unarr/commit/a9c2c6f71ad3ad5f3fd0bfed2b06148b51ed7555\n注: 本网站为完全开放社区，欢迎广大爱好者通过为 website 发起 PR 进行投稿！\n","permalink":"/zh-cn/posts/2021q4-upstream-community/","series":null,"tags":["新闻"],"title":"2021年四季度社区动态"},{"categories":[""],"content":"2021年三季度，LoongArch 平台开发者手册开放更新中；基础软件、开发语言、系统软件继续稳步推进；社区发行版数量有所增加。\n开发者手册 龙芯架构 ELF psABI ：该手册介绍了龙芯架构 ELF psABI。\n龙芯架构工具链约定 ：该手册介绍了龙芯架构工具链的命令行界面和操作系统相关惯例。\n以上手册作为开发者必备的参考资料，同时也是指导工具链实现的规范，目前在社区开放讨论并持续更新中， https://github.com/loongson/LoongArch-Documentation\n基础软件 EDK2 龙芯 UEFI 固件基于 edk2 开发，已经使用在 3A5000/3C5000L 等大量设备中，为了向上游推送代码，目前已经做了一些前期的准备工作。\n DHCPv6 协议增加 LoongArch 架构支持  新增了 0x25、0x26、0x27、0x28 等 ID，这些 ID 在 PXE 网络启动时会用到。\n0x00 0x25\tLoongArch 32-bit UEFI 0x00 0x26\tLoongArch 32-bit UEFI boot from http 0x00 0x27\tLoongArch 64-bit UEFI 0x00 0x28\tLoongArch 64-bit UEFI boot from http 文档地址： https://www.iana.org/assignments/dhcpv6-parameters/dhcpv6-parameters.xhtml#processor-architecture\nPE 格式增加 LoongArch 架构支持  Machine Types\n   Constant Value Description     IMAGE_FILE_MACHINE_LOONGARCH32  0x6232  LoongArch 32-bit processor family    IMAGE_FILE_MACHINE_LOONGARCH64  0x6264  LoongArch 64-bit processor family     Base Relocation Types\n   Constant Value Description     IMAGE_REL_BASED_LOONGARCH32_MARK_LA  8  This relocation is only meaningful when the machine type is LoongArch 32-bit. The base relocation applies to a 32-bit absolute address formed in two consecutive instructions.    IMAGE_REL_BASED_LOONGARCH64_MARK_LA  8  This relocation is only meaningful when the machine type is LoongArch 64-bit. The base relocation applies to a 64-bit absolute address formed in four consecutive instructions.     文档地址： https://docs.microsoft.com/en-us/windows/win32/debug/pe-format\n提交记录： https://github.com/MicrosoftDocs/win32/commit/491fd3ebca91029bb05d5d1a932c92b7d01731af\nLinux 内核代码和上游经过多轮沟通，一直在持续完善中，目前开发版本已迁移到 5.16.0-rc1 版本，分别维护在以下地址:\nGithub 仓库： https://github.com/loongson/linux/tree/loongarch-next\nkernel.org 仓库： https://git.kernel.org/pub/scm/linux/kernel/git/chenhuacai/linux-loongson.git/log/?h=loongarch-next\nBinutils Liu Zhensong 提交的 LoongArch 补丁已合并上游。\nhttps://sourceware.org/git?p=binutils-gdb.git;a=commit;h=01a8c731aacbdbed0eb5682d13cc074dc7e25fb3\nhttps://sourceware.org/git?p=binutils-gdb.git;a=commit;h=e214f8db56f65531b0a5ec296c42339dcaa5af31\nhttps://sourceware.org/git?p=binutils-gdb.git;a=commit;h=6cc76c40a99bd13d69a311cae5ec891bd1d1dbf2\nhttps://sourceware.org/git?p=binutils-gdb.git;a=commit;h=e9a0721f8274daeffaedbc3cabc12c52d43a38a7\nhttps://sourceware.org/git?p=binutils-gdb.git;a=commit;h=4462d7c440247bfcdc464412332bbec13b8aab12\ngcc https://github.com/loongson/gcc\n持续完善中\nglibc https://github.com/loongson/glibc\n持续完善中\nQEMU LoongArch TCG host 移植已经全部完成，预计将在 QEMU 7.0 分支开放后合并（WANG Xuerui）：\nhttps://patchew.org/QEMU/20211124183231.1503090-1-git@xen0n.name/\nLoongArch linux-user 模拟正在 code review 流程中（Gao Song）：\nhttps://patchew.org/QEMU/1637302410-24632-1-git-send-email-gaosong@loongson.cn/\nLoongArch TCG Dev 初步的 LA 系统模拟支持，在开放 review 中（Yang Xiaojuan）：\nhttps://github.com/loongson/qemu/pull/12\n开发语言 Javascript Javascript V8 引擎已经合入 LoongArch 架构支持(loong64)。\nhttps://chromium.googlesource.com/v8/v8.git github 镜像 系统软件 box64\nZhao Zhen 提交的 LoongArch 架构支持补丁上游已合并。\nhardinfo\nLiu Xiang 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/lpereira/hardinfo/commit/56e590d477a6422639235a6afe97f0c9637c459a\nhttps://github.com/ptitSeb/box64/commit/d75116dab7ca889f21379697b91b942b59588ee1\njemalloc\nWang Jinlong 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/jemalloc/jemalloc/commit/2159615419a90b5473cfd9d3a4cb4700259d8c0b\nnumactl\nHan Jianjun 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/numactl/numactl/commit/a5a429c6bd844308194a334c724e3a3e7f4a5806\nNumpy\nZhang Na 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/numpy/numpy/commit/640d68ac8593be4006ea1e63f0354d7b07767541\nhttps://github.com/numpy/numpy/commit/5f7f37ab49718e13038998673830411342e5ecdd\npatchelf\nZhang Wenlong 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/NixOS/patchelf/commit/a174cf3006baf31e0e9eaa62bc9adead93af63f7\npty\nChen Guoqi 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/creack/pty/commit/b135084511330383e4d0adc4504cf407cab59bb0\ntbox\nZhao Zhen 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/tboox/tbox/commit/7ca5145d40aa906fdc48b0b0e75e80412241be7e\nxrdp\nLiu Xiang 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/neutrinolabs/xrdp/commit/c36f92049deb2693ac789cce4db51d833886574b\nunarr\nLiu Xiang 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/selmf/unarr/commit/6c0bf9731fd80dbe843d2f546f3be92840613ae1\nsyscalls-table\nWANG Xuerui 提交的 LoongArch 架构支持补丁上游已合并。\nhttps://github.com/hrw/syscalls-table/commit/599c8a563292e677aaf14a5e51a1039c4a4c108b\n社区发行版 随着支持 LoongArch 架构的软件逐步开放和完善，一批社区发行版已经在加速开发中:\nArchlinux\n旧版(Alpha): http://archlinux.oukan.online/alpha/bootstrap/archlinux-bootstrap-alpha-2021.06.11-loongarch64.tar.zst\n新版：开发中\nAOSC\nhttps://gitlab.summer-ospp.ac.cn/summer2021/210080299/-/blob/main/README.md\nCLFS\nhttps://github.com/sunhaiyong1978/CLFS-for-LoongArch\nGentoo\n自举已经完成，stage3、LiveCD 确认可以工作。请配合 https://github.com/xen0n/loongson-overlay 使用\nhttp://loongson-pub-gz.qnbkt.xen0n.name/stage3-loong-systemd-20211205.tar.xz http://loongson-pub-gz.qnbkt.xen0n.name/stage3-loong-systemd-20211205.tar.xz.CONTENTS.gz http://loongson-pub-gz.qnbkt.xen0n.name/stage3-loong-systemd-20211205.tar.xz.DIGESTS\nLoongnix\ndesktop: http://pkg.loongnix.cn:8080/loongnix/isos/ server: http://pkg.loongnix.cn/loongnix-server/8.3/isos/loongarch64/\nOpenAnolis(龙蜥)\nhttps://mirrors.openanolis.cn/anolis/8.4/isos/BETA/loongarch64/\nOpenEuler(欧拉)\n开发中\n注: 本网站为完全开放社区，欢迎广大爱好者通过给 website 发起 PR 进行投稿！\n","permalink":"/zh-cn/posts/2021116-upstream-community/","series":null,"tags":["新闻"],"title":"2021年三季度社区动态"},{"categories":["固件","UEFI"],"content":"经过两年的开发，龙芯平台的固件已经实现了 UEFI 规范，从 3A5000 开始默认使用支持 UEFI 的固件。\n简介 UEFI(统一可扩展固件接口)，英文全称为 Unified Extensible Firmware Interface，是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面，作为 BIOS 的替代方案。可扩展固件接口负责加电自检（POST）、联系操作系统以及提供连接操作系统与硬件的接口。\nUEFI 的前身是 Intel 在1998年开始开发的 Intel Boot Initiative，后来被重命名为可扩展固件接口（Extensible Firmware Interface，缩写EFI）。Intel在2005年将其交由统一可扩展固件接口论坛（Unified EFI Forum）来推广与发展，为了凸显这一点，EFI 也更名为UEFI（Unified EFI）。UEFI 论坛的创始者是11家知名电脑公司，包括 Intel、IBM 等硬件厂商，软件厂商 Microsoft，及 BIOS 厂商 AMI、Insyde 及 Phoenix。\n目前主流的电脑都已经提供支持 UEFI 的固件，龙芯从 2018 年开始对edk2进行移植，并在3A4000上进行了试验性使用，从 3A5000 开始，将默认使用支持 UEFI 的固件。\nGPT 分区表 GPT: GUID（Globals Unique Identifiers）Partition Table 全局唯一标识，是一个较新的分区机制，解决了MBR很多缺点。\n使用128位 UUID 表示磁盘和分区 GPT 分区表自动备份在头和尾两份，并有CRC校验位\n支持超过2T的磁盘（64位寻址空间），使用64位，支持128个分区，支持8Z（512Byte/block ）64Z（4096Byte/block）。fdisk 最大只能建立2TB大小的分区，创建一个大于2TB的分区使用 parted，gdisk 分区工具。\n特点：\n 向后兼容MBR 必须在支持 UEFI 的硬件上才能使用（Intel提出，用于取代BIOS） 必须使用64位系统 Mac、Linux 系统都能支持 GPT 分区格式 Windows 7/8 64bit、Windows Server 2008 64bit 支持 GPT  要使用 UEFI，硬盘需要使用 GPT 分区表。\nEFI 系统分区 UEFI规范里，在GPT分区表的基础上，规定了一个EFI系统分区（EFI System Partition，ESP），ESP要格式化成FAT32，EFI启动文件要放在 \u0026lt;esp分区\u0026gt;/EFI 目录下面。\n在龙芯固件中，默认的EFI文件加载路径是 \u0026lt;esp\u0026gt;/EFI/BOOT/BOOTLOONGARCH64.EFI，当写入固件的启动项失败时，可以将 efi 文件放在这个路径，以让固件自动加载。\n注：\n未提交上游的旧固件版本，默认的EFI文件加载路径是 \u0026lt;esp\u0026gt;/EFI/BOOT/BOOTLOONGARCH.EFI。\nEFI 系统分区，通过挂载在 /boot/efi 目录中：\n/dev/sda1 on /boot/efi type vfat (rw,relatime,fmask=0022,dmask=0022,codepage=936,iocharset=cp936,shortname=mixed,utf8,errors=remount-ro) 固件启动项 启动过程中，当显示红色 LOONSON 界面时，按下F12键，会出现固件启动项：\n/-----------------------------------\\ | Please select boot device: | |-----------------------------------| | arch | | rEFInd Boot Manager | | UEFI S5170-256 | | UEFI Shell | | Enter Setup | |-----------------------------------| | ^ and v to move selection | | ENTER to select boot device | | ESC to exit | \\-----------------------------------/ 选择 arch 将进入 grub，(Archlinux发行版会修改grub安装后的名称)。\n选择 rEFInd Boot Managerarch 将进入refind界面。\n选择 UEFI S5170-256 将加载硬盘上的默认efi文件。\n选择 UEFI Shell 将进入固件交互命令行界面。\n选择 Enter Setup 将进入固件设置界面。\nUEFI Shell  help: 显示内置到 UEFI Shell 的命令列表。  Shell\u0026gt; help alias - Displays, creates, or deletes UEFI Shell aliases. attrib - Displays or modifies the attributes of files or directories. bcfg - Manages the boot and driver options that are stored in NVRAM. cd - Displays or changes the current directory. cls - Clears the console output and optionally changes the background and foreground color. comp - Compares the contents of two files on a byte-for-byte basis. connect - Binds a driver to a specific device and starts the driver. cp - Copies one or more files or directories to another location. date - Displays and sets the current date for the system. dblk - Displays one or more blocks from a block device. devices - Displays the list of devices managed by UEFI drivers. devtree - Displays the UEFI Driver Model compliant device tree. dh - Displays the device handles in the UEFI environment. disconnect - Disconnects one or more drivers from the specified devices. dmem - Displays the contents of system or device memory. dmpstore - Manages all UEFI variables. drivers - Displays the UEFI driver list. drvcfg - Invokes the driver configuration. drvdiag - Invokes the Driver Diagnostics Protocol. echo - Controls script file command echoing or displays a message. edit - Provides a full screen text editor for ASCII or UCS-2 files. eficompress - Compresses a file using UEFI Compression Algorithm. efidecompress - Decompresses a file using UEFI Decompression Algorithm. else - Identifies the code executed when \u0026#39;if\u0026#39; is FALSE. endfor - Ends a \u0026#39;for\u0026#39; loop. endif - Ends the block of a script controlled by an \u0026#39;if\u0026#39; statement. exit - Exits the UEFI Shell or the current script. for - Starts a loop based on \u0026#39;for\u0026#39; syntax. getmtc - Gets the MTC from BootServices and displays it. goto - Moves around the point of execution in a script. help - Displays the UEFI Shell command list or verbose command help. hexedit - Provides a full screen hex editor for files, block devices, or memory. if - Executes commands in specified conditions. ifconfig - Modifies the default IP address of the UEFI IPv4 Network Stack. load - Loads a UEFI driver into memory. loadpcirom - Loads a PCI Option ROM. ls - Lists the contents of a directory or file information. map - Displays or defines file system mappings. memmap - Displays the memory map maintained by the UEFI environment. mkdir - Creates one or more new directories. mm - Displays or modifies MEM/MMIO/IO/PCI/PCIE address space. mode - Displays or changes the console output device mode. mv - Moves one or more files to a destination within or between file systems. openinfo - Displays the protocols and agents associated with a handle. parse - Retrieves a value from a standard format output file. pause - Pauses a script and waits for an operator to press a key. pci - Displays PCI device list or PCI function configuration space and PCIe extended configuration space. pcieswitch - PCIE signal test switch. pcietest - PCIE signal test. ping - Ping the target host with an IPv4 stack. reconnect - Reconnects drivers to the specific device. reset - Resets the system. rm - Deletes one or more files or directories. rtcWakeup - Test rtc wakeup after Shutdown. run - Load and run the linux kernal. satatest - SATA signal test. sermode - Sets serial port attributes. set - Displays or modifies UEFI Shell environment variables. setsize - Adjusts the size of a file. setvar - Displays or modifies a UEFI variable. shift - Shifts in-script parameter positions. smbiosview - Displays SMBIOS information. spi - Read or write spi flash. stall - Stalls the operation for a specified number of microseconds. time - Displays or sets the current time for the system. timezone - Displays or sets time zone information. touch - Updates the filename timestamp with the current system date and time. type - Sends the contents of a file to the standard output device. unload - Unloads a driver image that was already loaded. usbtest - USB signal test. ver - Displays UEFI Firmware version information. vers - Displays Loongson UEFI build version information. vol - Displays or modifies information about a disk volume. 常用命令说明：\n set: 创建、显示、更改或删除 UEFI Shell 环境变量。  Shell\u0026gt; set path = FS0:\\efi\\tools\\;FS0:\\efi\\boot\\;FS0:\\;FS1:\\efi\\tools\\;FS1:\\efi\\boot\\;FS1:\\;FS2:\\efi\\tools\\ ;FS2:\\efi\\boot\\;FS2:\\;FS3:\\efi\\tools\\;FS3:\\efi\\boot\\;FS3:\\ nonesting = False debuglasterror = 0x0 lasterror = 0x0 profiles = ;Driver1;Debug1;network1;spi;signal test;LoongsonTest;vers; uefishellsupport = 3 uefishellversion = 2.2 uefiversion = 2.70  ver: 显示固件版本信息  Shell\u0026gt; ver UEFI Interactive Shell v2.2 EDK II UEFI v2.70 (EDK II, 0x00010000)  cd: 显示或更改当前目录。  Shell\u0026gt; help cd Displays or changes the current directory. CD [path] path - Specifies the relative or absolute directory path. NOTES: 1. This command changes the current working directory that is used by the UEFI Shell environment. If a file system mapping is specified, then the current working directory is changed for that device. Otherwise, the current working directory is changed for the current device. 2. If path is not present, then the current working directory (including file system mapping) is displayed to standard out. 3. The table below describes the conventions that are used to refer to the directory, its parent, and the root directory in the UEFI Shell environment. Convention Description \u0026#39;.\u0026#39; Refers to the current directory. \u0026#39;..\u0026#39; Refers to the directory\u0026#39;s parent. \u0026#39;\\\u0026#39; Refers to the root of the current file system. 4. The current working directory is maintained in the environment variable %cwd%. EXAMPLES: * 将当前文件系统变为映射的 fs0 文件系统： Shell\u0026gt; fs0: * 将当前目录变为 efi 子目录： fs0:\\\u0026gt; cd efi * 将当前目录变为父目录 (fs0:\\): fs0:\\efi\\\u0026gt; cd .. * 将当前目录变为 \u0026#39;fs0:\\efi\\Tools\u0026#39;: fs0:\\\u0026gt; cd efi\\Tools * 将当前目录变为当前 fs 的根目录 (fs0): fs0:\\efi\\Tools\\\u0026gt; cd \\ Shell\u0026gt;  reset: 重启或关机  Shell\u0026gt; help reset Resets the system. RESET [-w [string]] RESET [-s [string]] RESET [-c [string]] -s - 关机 -w - 热启动 -c - 冷启动 string - 给出一个原因并重启 NOTES: 1. This command resets the system. 2. The default is to perform a cold reset unless the -w parameter is specified. 3. If a reset string is specified, it is passed into the Reset() function, and the system records the reason for the system reset.  spi: 固件刷新  Shell\u0026gt; help spi Read or write spi flash. SPI [-r StartAddr Size]/[-w data/-w StartAddr data]/[-u file]/[-e]/[-l file StartAddr Size] -r - read ls7a spi from address. -w - write ls7a spi data. -u - update ls3a spi flash. -e - erase ls7a spi flash by Sector. -x - download correct firmware to Serial ROM for xhci. -l - write ls7a spi data from start address to end address NOTES: 1. This command can update flash you should be careful. * 刷新固件 fs0:\\\u0026gt; spi -u uefi * write the ls7a spi flash: fs0:\\\u0026gt; spi -w 00:11:22:33:44:55 fs0:\\\u0026gt; spi -w 0x10 aa:bb:cc:dd:ee:ff * write the ls7a spi flash: fs0:\\\u0026gt; spi -l vbios.bin 0x1000 0x20000 Shell\u0026gt; 操作系统支持 基于 3A5000 平台的操作系统内核已经增加了对固件 Variable Runtime Services 的支持，可以在操作系统中直接操作固件提供的 Runtime 服务，如增加、删除引导项，调整启动顺序等。\n要使用操作系统的这个功能，需要:\n 在编译内核时，打开 CONFIG_EFIVAR_FS=m 配置项，在 make menuconfig 时，显示为：  \u0026lt;M\u0026gt; EFI Variable Support via sysfs 挂载 efivarfs 文件系统  如果操作系统使用了 systemd，在启动时会自动挂载，挂载位置如下：\nefivarfs on /sys/firmware/efi/efivars type efivarfs (rw,nosuid,nodev,noexec,relatime) 编译并安装 efibootmgr 软件包。  efibootmgr 命令用法如下：\n$ efibootmgr -h efibootmgr version 17 usage: efibootmgr [options] -a | --active sets bootnum active -A | --inactive sets bootnum inactive -b | --bootnum XXXX modify BootXXXX (hex) -B | --delete-bootnum delete bootnum -c | --create create new variable bootnum and add to bootorder -C | --create-only create new variable bootnum and do not add to bootorder -D | --remove-dups remove duplicate values from BootOrder -d | --disk disk (defaults to /dev/sda) containing loader -r | --driver Operate on Driver variables, not Boot Variables. -e | --edd [1|3|-1] force EDD 1.0 or 3.0 creation variables, or guess -E | --device num EDD 1.0 device number (defaults to 0x80) -g | --gpt force disk with invalid PMBR to be treated as GPT -i | --iface name create a netboot entry for the named interface -l | --loader name (defaults to \u0026#34;\\EFI\\arch\\grub.efi\u0026#34;) [1] -L | --label label Boot manager display label (defaults to \u0026#34;Linux\u0026#34;) -m | --mirror-below-4G t|f mirror memory below 4GB -M | --mirror-above-4G X percentage memory to mirror above 4GB -n | --bootnext XXXX set BootNext to XXXX (hex) -N | --delete-bootnext delete BootNext -o | --bootorder XXXX,YYYY,ZZZZ,... explicitly set BootOrder (hex) -O | --delete-bootorder delete BootOrder -p | --part part partition containing loader (defaults to 1 on partitioned devices) -q | --quiet be quiet -t | --timeout seconds set boot manager timeout waiting for user input. -T | --delete-timeout delete Timeout. -u | --unicode | --UCS-2 handle extra args as UCS-2 (default is ASCII) -v | --verbose print additional information -V | --version return version and exit -w | --write-signature write unique sig to MBR if needed -y | --sysprep Operate on SysPrep variables, not Boot Variables. -@ | --append-binary-args file append extra args from file (use \u0026#34;-\u0026#34; for stdin) -h | --help show help/usage 注: [1] 这里显示的 \u0026ldquo;\\EFI\\arch\\grub.efi\u0026rdquo; 是当前启动项所使用的 efi 文件位置，非原始默认位置。\n 查看当前启动项信息  $ efibootmgr -v BootCurrent: 0005 Timeout: 3 seconds BootOrder: 0005,0004,0001,0002,0003,0000 Boot0000* Enter Setup\tFvVol(7cb8bdc9-f8eb-4f34-aaea-3ee4af6516a1)/FvFile(462caa21-7614-4503-836e-8ab6f4662331) Boot0001 UEFI BootManagerMenuApp\tFvVol(7cb8bdc9-f8eb-4f34-aaea-3ee4af6516a1)/FvFile(eec25bdc-67f2-4d95-b1d5-f81b2039d11d) Boot0002* UEFI S5170-256\tPciRoot(0x0)/Pci(0x8,0x0)/Sata(0,65535,0)N.....YM....R,Y. Boot0003* UEFI Shell\tFvVol(7cb8bdc9-f8eb-4f34-aaea-3ee4af6516a1)/FvFile(7c04a583-9e3e-4f1c-ad65-e05268d0b4d1) Boot0004* rEFInd Boot Manager\tHD(1,GPT,125d060a-911a-4a4f-ba44-7035cb7bad01,0x800,0xfa000)/File(\\EFI\\refind\\refind_loongarch64.efi) Boot0005* arch\tHD(1,GPT,125d060a-911a-4a4f-ba44-7035cb7bad01,0x800,0xfa000)/File(\\EFI\\arch\\grubloongarch64.efi) 当前启动项是0005，即arch，efi文件是 \u0026lt;esp\u0026gt;/EFI/arch/grub/loongarch64.efi。\n启动顺序是0005(arch),0004(rEFInd Boot Manager),0001(UEFI BootManagerMenuApp),0002(UEFI S5170-256),0003(UEFI Shell),0000(Enter Setup)。\n调整启动顺序  交换arch和rEFInd Boot Manager：\n# efibootmgr -o 0004,0005,0001,0002,0003,0000 添加新启动项  将文件 /boot/efi/EFI/BOOT/BOOTLA64.EFI 添加为新的启动项Linux Boot Manager。\n# efibootmgr -c -w -L \u0026#34;Linux Boot Manager\u0026#34; -d /dev/sda -p 1 -l \\EFI\\BOOT\\BOOTLA64.EFI BootCurrent: 0005 Timeout: 3 seconds BootOrder: 0006,0005,0004,0001,0002,0003,0000 Boot0000* Enter Setup Boot0001 UEFI BootManagerMenuApp Boot0002* UEFI S5170-256 Boot0003* UEFI Shell Boot0004* rEFInd Boot Manager Boot0005* arch Boot0006* Linux Boot Manager 删除启动项  删除刚才添加的启动项：\n$ efibootmgr -b 0006 -B BootCurrent: 0005 Timeout: 3 seconds BootOrder: 0005,0004,0001,0002,0003,0000 Boot0000* Enter Setup Boot0001 UEFI BootManagerMenuApp Boot0002* UEFI S5170-256 Boot0003* UEFI Shell Boot0004* rEFInd Boot Manager Boot0005* arch efibootmgr 工具还有许多功能（比如隐藏启动项、修改启动项、删除无用的启动项、超时时间等），这里不再一一介绍，有兴趣的朋友可以自行研究测试。\nhelloworld 应用 UEFI 支持用户自行开发efi application，如比较常见的bootloader、memtest、uefi shell等等，都是一个个UEFI Application。\n开发应用可以使用UEFI提供的头文件和库，也可以使用 gnu-efi 封装的专用于 linux 工具链的开发库，我们以使用 gnu-efi 为例，编写一个能输出 \u0026ldquo;Hello, world!\u0026rdquo; 的 应用。\n编写 main.c 文件，内容如下：\n#include \u0026lt;efi.h\u0026gt;#include \u0026lt;efilib.h\u0026gt; EFI_STATUS EFIAPI efi_main (EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) { InitializeLib(ImageHandle, SystemTable); Print(L\u0026#34;Hello, world!\\n\u0026#34;); return EFI_SUCCESS; } 编写 Makefile 文件，内容如下：\nARCH = $(shell uname -m | sed s,i[3456789]86,ia32,) OBJS = main.o TARGET = hello.efi EFIINC = /usr/include/efi EFIINCS = -I$(EFIINC) -I$(EFIINC)/$(ARCH) -I$(EFIINC)/protocol LIB = /usr/lib EFI_CRT_OBJS = $(LIB)/crt0-efi-$(ARCH).o EFI_LDS = $(LIB)/elf_$(ARCH)_efi.lds CFLAGS = $(EFIINCS) -fno-stack-protector -fpic \\  -fshort-wchar -Wall ifeq ($(ARCH),loongarch64) CFLAGS += -march=loongarch64 -mabi=lp64 -g -O2 \\  -Wextra -Werror -fno-strict-aliasing \\  -ffreestanding -fno-stack-check \\  $(if $(findstring gcc,$(CC)),-fno-merge-all-constants,) endif LDFLAGS = -nostdlib --warn-common --no-undefined --fatal-warnings -shared \\  --build-id=sha1 -Bsymbolic --defsym=EFI_SUBSYSTEM=0xa -T $(EFI_LDS) -L $(LIB) $(EFI_CRT_OBJS) \\  all: $(TARGET) hello.so: $(OBJS) ld $(LDFLAGS) $(OBJS) -o $@ -lefi -lgnuefi %.efi: %.so @objcopy -j .text -j .sdata -j .data -j .dynamic -j .dynsym -j .rel \\  -j .rela -j .rel.* -j .rela.* -j .rel* -j .rela* \\  -j .reloc -O binary $^ $@ clean: @rm -f *.o *.efi *.so 编译\n$ make 复制 efi 到 esp 分区：\n$ cp hello.efi /boot/efi/hello.efi 重启系统，进入 UEFI Shell 进行测试：\nShell\u0026gt; fs0:\\hello.efi Hello, world! Shell\u0026gt; 更多测试请 clone https://github.com/loongarch64/gnu-efi 仓库，切换到 dev-la64/master 分支，编译运行。\n$ git clone https://github.com/loongarch64/gnu-efi $ git checkout dev-la64/master $ make $ make apps $ ls loongarch64/apps/ AllocPages.efi debughook.efi drv0.efi exit.efi lfbgrid.efi printenv.efi setdbg.efi t2.efi t4.efi t6.efi t8.efi t.efi bltgrid.efi debughook.efi.debug drv0_use.efi FreePages.efi modelist.efi route80h.efi setjmp.efi t3.efi t5.efi t7.efi tcc.efi unsetdbg.efi 生成的 efi 文件位于 loongarch64/apps 目录中，可以通过 UEFI Shell 来加载这些 efi 文件进行测试和学习编写固件 efi 应用。\nstartup.nsh 脚本 UEFI 固件支持自动加载脚本来执行一系列自动化任务，将编写好的 startup.nsh 脚本复制到 \u0026lt;esp\u0026gt;/efi/tools/startup.nsh，重启系统可自动执行。\n下面是一个脚本示例：\ncat /boot/efi/tools/startup.nsh cls echo \u0026#34;Press any key to continue...\u0026#34; pause if exist fs0:\\hello.efi then echo \u0026#34;Run hello.efi...\u0026#34; fs0:\\hello.efi endif if exist fs0:\\EFI\\arch\\grubloongarch64.efi then echo \u0026#34;Run Grub...\u0026#34; fs0:\\EFI\\arch\\grubloongarch64.efi endif 脚本先进行清屏，然后显示Press any key to continue..., 并等待用户按键。\n如果 /boot/efi/hello.efi 文件存在，则显示 Run hello.efi... 并加载执行 hello.efi。\n如果 /boot/efi/EFI/arch/grubloongarch64.efi 文件存在，则显示 Run Grub... 并加载执行，进行 Grub 界面。\n","permalink":"/zh-cn/posts/3a5000-uefi/","series":null,"tags":["新闻"],"title":"3A5000之UEFI"},{"categories":[""],"content":"2021年二季度，LoongArch 平台的基础软件、开发语言及系统软件正逐步开放并积极向上游提交中\u0026hellip;\n基础软件 内核 内核经过代码移植和重新整理，目前最新开发版本 5.14 分别维护在以下地址:\nGithub 仓库: https://github.com/loongson/linux/tree/loongarch-next\nkernel.org 仓库: https://git.kernel.org/pub/scm/linux/kernel/git/chenhuacai/linux-loongson.git/log/?h=loongarch-next\n为了让内核早日进入主线，Huacai Chen 从 2021 年 7 月 6 日开始，与上游社区进行了多轮沟通，并积极按社区要求对补丁进行修订，期待上游能早日合并。\n感兴趣可阅读这里: https://lore.kernel.org/linux-arch/20210706041820.1536502-1-chenhuacai@loongson.cn/\n工具链 LoongArch 工具链经过紧张的移植、测试，目前已经升级到最新开发版本:\ngcc: https://github.com/loongson/gcc\nbinutils: https://github.com/loongson/binutils-gdb\nglibc: https://github.com/loongson/glibc\n工具链期待更多的测试和反馈，也欢迎各位社区爱好者能参与完善。\n预编译好的交叉编译工具链及 rootfs 环境，请参见这里: https://github.com/loongson/build-tools\nqemu https://github.com/loongson/qemu/pull/1\nqemu 的 user-mode 的代码正在开放 review 中。\n同学们即便暂时没有 3A5000 机器，LoongArch 汇编也可以学起来了。\n开发语言 Go https://go-review.googlesource.com/c/go/+/333909\nWANG Xuerui 提交了预留 GOARCH=loong64 架构的补丁，上游已经审核通过，预计于 go-1.17 版本中发布。\n龙芯已将先前移植的 go-1.15.6 源码放出，代码仓库: https://github.com/loongson/go\nJava Ao Qi 为 OpenJDK 提交了最基础的 LoongArch 架构支持，代码已被合并。\nhttps://github.com/openjdk/jdk/commit/e92e2fd4e0bc805d8f7d70f632cce0282eb1809b\n系统软件 bdwgc\nZhang Na 提交了与 LoongArch 架构相关的补丁，并于 2021 年 7 月 14 日被合并到主分支。\nhttps://github.com/ivmai/bdwgc/commit/c86b7fc0750e518d6f85d4f4e95a87bbc309572b\nbotan\nZhang Na 提交了与 LoongArch 架构相关的补丁，并于 2021 年 7 月 12 日被合并到主分支。\nhttps://github.com/randombit/botan/commit/6eb5a8a8c883025cb204c91fd2c1ccafca357364\ndouble-conversion\nhoufangdong 提交了与 LoongArch 架构相关的补丁，并于 2021 年 5 月 19 日被合并到主分支。\nhttps://github.com/google/double-conversion/commit/32bc443c60c860eb6b4843533a614766d611172e\nfile\nWu Xiaotian 提交了与 LoongArch 架构相关的补丁，并于 2021 年 5 月 25 日被合并到主分支。\nhttps://github.com/file/file/commit/0d47491f8f7134940bbd33b98a77a36dff4879b3\ngsl\nZhang Na 提交了与 LoongArch 架构相关的补丁，并于 2021 年 7 月 9 日被合并到主分支。\nhttps://github.com/zeromq/gsl/commit/780e07ad647dd4ee55444ba83be71af84c8b9ca7\nhwinfo\njinqingchen 提交了与 LoongArch 架构相关的补丁，并于 2021 年 7 月 2 日被合并到主分支。\nhttps://github.com/openSUSE/hwinfo/pull/100\nlibaio\nyehui ren 提交了与 LoongArch 架构相关的补丁，并于 2021 年 7 月 20 日被合并到主分支。\nhttps://pagure.io/libaio/c/48f4fb7d688e26b05c76e3d0fabdefc6c5f66241?branch=master\nhttps://pagure.io/libaio/c/97076c8a55064e6f34483d41f6bffff3838f5b61?branch=master\nhttps://pagure.io/libaio/c/de492eef5edf3b6f61d069f1a723d011228ee567?branch=master\nhttps://pagure.io/libaio/c/d892696468cb99d7d98b23b78bde942df0992d5a?branch=master\nlibmowgli-2\nzhangjialing 提交了与 LoongArch 架构相关的补丁，并于 2021 年 6 月 4 日被合并到主分支。\nhttps://github.com/atheme/libmowgli-2/commit/bd45f33c87e1dd4744300a70bbc91c0d04f87c49\nhttps://github.com/atheme/libmowgli-2/commit/669ec93899b35e464aed1fb503319377a0961cba\nlinux-rdma\nwangguofeng 提交了与 LoongArch 架构相关的补丁，并于 2021 年 8 月 2 日被合并到主分支。\nhttps://github.com/linux-rdma/rdma-core/commit/071c10a24b11b7c54d80917a8d1c146f956f9848\nmatio\nzhangjialing 提交了与 LoongArch 架构相关的补丁，并于 2021 年 6 月 3 日被合并到主分支。\nhttps://github.com/tbeu/matio/commit/f93a57597c9df27bbce98b6a9a4e24ebd205eca1\nsystemd\nWANG Xuerui 提交了与 LoongArch 架构相关的补丁，并于 2021 年 7 月 14 日被合并到主分支。\nhttps://github.com/systemd/systemd/commit/3cfd5ddd59aa4a7c365bd86fa7755610e8ad7296\nutil-linux\nWANG Xuerui 提交了与 LoongArch 架构相关的补丁，并于 2021 年 8 月 2 日被合并到主分支。\nhttps://github.com/karelzak/util-linux/commit/2d29fccaad267d1b003dc0ed2bb9634ff76f3e49\n目前还有一些系统软件正在 review 中，详情见 https://github.com/loongarch64 组织。\n注: 本网站为完全开放社区，欢迎广大爱好者通过给 website 发起 PR 进行投稿！\n","permalink":"/zh-cn/posts/20210801-upstream-community/","series":null,"tags":["新闻"],"title":"2021年二季度社区动态"},{"categories":null,"content":"本文讲解如何交叉编译一个基于LoongArch架构的LFS（Linux From Scratch）系统。\n（CLFS For LoongArch64）\n作者：孙海勇\n0 前言 　龙芯中科于2021年推出了全新指令集架构LoongArch，其中64位指令集称为LoongArch64。\n　本文的目标是为LoongArch64制作一套基本的Linux系统，作为对新的指令集架构而制作Linux系统，我们可以默认该架构平台上无可运行的系统为前提，采用交叉编译的方式为其制作一套基本的Linux系统。\n1 关于软件包的移植 　对于本文所制作的目标系统是基于LoongArch64架构的Linux系统，对于LoongArch64架构所使用的指令集在本文发布时属于比较新的，很多Linux系统的基本软件包中都没有包含该指令集相关的支持，为了解决支持新架构的问题，可根据不同情况的软件包采用不同的处理方式。\n 扩充式移植软件包  　这类软件包通常在Linux系统中与具体指令集架构细节打交道的软件包，例如：Linux内核、GCC、Binutls、Glibc以及LLVM等等，且这些软件包通常需要大量代码的加入才能支持新的指令集架构。\n　对于这类软件包，如果想以最佳的手段支持新指令集架构，那么当然是提交到官方的最新版本中并得到长期的支持，但要达到这样的结果是需要一个过程的，那么在这个过程中则可以采用“打补丁”的方式。但因通常这些软件包需要修改和增加大量的代码，这使得补丁文件通常针对具体的版本，当版本升级后通常补丁不能直接使用，所以要使用对应版本的源代码来使用补丁。\n　另一种“不太好”的方式是添加了新架构的完整源代码整体提供下载，即补丁已经打在源代码中，这样只要下载修改过的软件包源码就可以使用了。\n 简易移植软件包  　这类软件包代码上基本上不涉及汇编或者有非汇编的实现（汇编通常作为优化性能的手段），此类软件包通常有多种指令集架构采用类似的工作行为，可在某一类工作行为上加入新指令集架构的判断或者通过较少的改动即可实现对新指令集架构的移植，比如：Systemd、Automake等，因此针对这类软件包的补丁具有较高的版本通用性，同一个补丁可能适合用于多个版本上，在该类软件包的官方支持新指令集架构之前，采用“打补丁”的方式更适合这类软件包的移植方式。\n 无需移植软件包  　这类软件包大多采用非汇编的开发语言进行编写，具有较强的通用性，通常在其所依赖的编译器或者运行环境进行了移植后就可以直接进行编译或使用了。例如Coreutils、Findutils等。\n　这类软件包也可能需要在配置阶段进行新架构的支持，主要是软件包自带的config.sub和config.guess检查目标系统时没有匹配的架构设置导致错误，这类问题比较好解决，只需要将增加了新架构的Automake软件包中的config.sub和config.guess覆盖软件包中的文件即可。\n　除了以上这些在新架构平台上可移植的软件包外还有一些软件包是针对某一个特定的指令集架构编写的，如果是非核心功能的软件包可以暂时忽略，如果有对应功能的可移植软件包也可以用来替代这些特定平台的软件包。\n2 准备工作 　在开始制作前，先做一些准备工作，这包括系统的准备、制作环境的设置以及软件包源代码的下载。\n2.1 系统的准备 　首先准备一台可以安装通用Linux系统的机器，对于要用来交叉编译目标平台的系统我们称为“主系统”，“主系统”可以是X86机器上的系统，也可以是其他架构机器上的系统，为了方便讲解，本文采用在X86架构上的Linux系统进行制作讲解。\n选择一个合适的Linux对于能否顺利完成制作还是有一定的作用，这里可以使用常见的发行版，如Fedora、Debian、CentOS等，也可以使用专门的系统，如LFS的LiveCD等，接下来我们以Fedora系统作为交叉编译的“主系统”进行讲解。\n为了使制作系统讲解的过程中尽量减少额外的因素导致的问题，我们在一个“重新搭建的”Fedora系统中进行制作，在一个支持dnf命令工具的系统中使用如下命令进行搭建：\nexport DISTRO_URL=https://mirrors.bfsu.edu.cn/fedora/releases/34/Everything/x86_64/os/ sudo dnf install @core @c-development rpm-build git python3-devel texinfo \\  zlib-devel xz-lzma-compat gettext-devel perl-FindBin \\  perl-Pod-Html rpm-devel tcl ncurses-devel openssl-devel bc \\  wget meson ninja-build gperf rsync \\  --installroot ${HOME}/la-clfs --disablerepo=\u0026#34;*\u0026#34; \\  --repofrompath base,${DISTRO_URL} \\  --releasever 34 --nogpgcheck 　以上步骤将在当前用户的目录中创建\u0026quot;la-clfs\u0026quot;的目录，在这个目录中将安装一个基本的制作环境，这里安装的是Fedora 34的系统，读者也可以安装其它的系统作为制作环境。\n　接下来的制作过程都将在这个目录中进行。\n　复制当前系统的域名解析配置文件到新建立的系统中，以便该系统可以访问网络资源。\ncp -a /etc/resolv.conf ${HOME}/la-clfs/etc/ 　接下来切换到该目录中:\nsudo chroot ${HOME}/la-clfs 　挂载必要的文件系统：\nmount -t proc proc proc mount -t sysfs sys sys mount -t devtmpfs dev dev mount -t devpts devpts dev/pts mount -t tmpfs shm dev/shm 2.2 制作环境的设置 创建必要的目录 　使用如下命令创建几个目录，后续的制作过程都将在这些目录中进行。\nexport SYSDIR=/opt/mylaos mkdir -pv ${SYSDIR} mkdir -pv ${SYSDIR}/downloads mkdir -pv ${SYSDIR}/build install -dv ${SYSDIR}/cross-tools install -dv ${SYSDIR}/sysroot 　简单说明一下这几个目录的用处：\n  通过设置“SYSDIR\u0026quot;变量方便对“基础目录”的使用，该变量设置了一个具体的目录作为“基础目录”，与本次制作相关的工作都在该目录中进行。\n  “downloads”目录用来存放各种软件的源码包以及补丁文件；\n  “build”目录用来编译各个软件包；\n  “cross-tools”目录用来存放交叉工具链及相关的软件；\n  “sysroot”用来存放目标平台系统。\n  创建制作用户 　为了防止制作过程中意外的对系统本身造成破坏，创建一个普通用户的账号，后续的制作过程除非需要特殊权限操作，否则对于目标系统的一切操作都使用该用户进行。\ngroupadd lauser useradd -s /bin/bash -g lauser -m -k /dev/null lauser 设置目录为新创建用户所属：\nchown -Rv lauser ${SYSDIR} chmod -v a+wt ${SYSDIR}/{sysroot,cross-tools,downloads,build} 切换到制作用户 　使用命令切换到新创建的用户：\nsu - lauser 　使用“su”命令进行切换时加上“-”参数可以防止切换前的用户环境变量带到新用户环境中。\n设置制作用户环境 　为制作用户设置最精简和必要的环境变量，以帮助后续制作过程的开展，以下为用户的环境变量进行长期设置。\ncat \u0026gt; ~/.bash_profile \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; exec env -i HOME=${HOME} TERM=${TERM} PS1=\u0026#39;\\u:\\w\\$ \u0026#39; /bin/bash EOF cat \u0026gt; ~/.bashrc \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; set +h umask 022 export SYSDIR=\u0026#34;/opt/mylaos\u0026#34; export BUILDDIR=\u0026#34;${SYSDIR}/build\u0026#34; export DOWNLOADDIR=\u0026#34;${SYSDIR}/downloads\u0026#34; export LC_ALL=POSIX export CROSS_HOST=\u0026#34;$(echo $MACHTYPE | sed \u0026#34;s/$(echo $MACHTYPE | cut -d- -f2)/cross/\u0026#34;)\u0026#34; export CROSS_TARGET=\u0026#34;loongarch64-unknown-linux-gnu\u0026#34; export MABI=\u0026#34;lp64\u0026#34; export BUILD_ARCH=\u0026#34;-march=loongarch\u0026#34; export BUILD_MABI=\u0026#34;-mabi=${MABI}\u0026#34; export BUILD64=\u0026#34;-mabi=lp64\u0026#34; export PATH=${SYSDIR}/cross-tools/bin:/bin:/usr/bin unset CFLAGS unset CXXFLAGS EOF 　这里设置了几个环境变量，下面简单介绍这些变量的含义：\n SYSDIR：方便引用“基础目录”，可以通过修改该变量所设置的路径来改变所使用的“基础目录”。 BUILDIR：该变量指定的目录用来进行软件包编译过程使用的目录。 DOWNLOADDIR：该变量指定的目录存放制作系统的过程中所需要的软件包及一些必要的补丁文件。 CROSS_HOST:设置“主系统”所使用的架构系统描述词 CROSS_TARGET：设置“目标系统”所使用的架构系统描述词。 MABI:指定“目标系统”默认使用的ABI名称。 BUILD_ARCH:设置编译“目标系统”中的软件包时使用的默认架构参数。 BUILD_MABI:设置编译“目标系统”中的软件包时使用的默认ABI参数。 BUILD64：设置编译“目标系统”中的软件包为64位ABI时使用的ABI参数。  　设置好用户环境配置文件后通过source命令使环境设置生效，使用命令：\nsource ~/.bash_profile 创建目标系统的目录结构 　我们要制作的目标系统是常规的Linux/GNU系统，我们按照常规的Linux/GNU系统所使用的目录结构创建目标系统的目录，命令如下:\npushd ${SYSDIR}/sysroot mkdir -pv ./{boot,home,root,mnt,opt,srv,run} mkdir -pv ./etc/{opt,sysconfig} mkdir -pv ./media/{floppy,cdrom} mkdir -pv ./usr/{,local/}{include,src} mkdir -pv ./usr/local/{bin,lib,sbin} mkdir -pv ./usr/{,local/}share/{color,dict,doc,info,locale,man} mkdir -pv ./usr/{,local/}share/{misc,terminfo,zoneinfo} mkdir -pv ./usr/{,local/}share/man/man{1..8} mkdir -pv ./var/{cache,local,log,mail,opt,spool} mkdir -pv ./var/lib/{color,misc,locate} mkdir -pv ./usr/{lib{,64},bin,sbin} ln -sfv usr/{lib{,64},bin,sbin} ./ mkdir -pv ./lib/firmware mkdir -pv ./{dev,proc,sys} ln -sfv ../run ./var/run ln -sfv ../run/lock ./var/lock install -dv -m 1777 ./tmp ./var/tmp popd 　目标系统将存放在${SYSDIR}/sysroot目录中，所以以该目录为基础创建各种目录和链接文件。\n2.3 下载软件包 　为了使用最新的软件包构建目标系统，这可能需要从网络中下载软件包源代码及补丁文件，下载的文件建议存放在“downloads”目录中。\npushd ${SYSDIR}/downloads 　然后可以使用wget工具下载相应版本的软件包，例如下载coreutils-8.32这个软件包，可使用命令：\nwget https://ftp.gnu.org/gnu/coreutils/coreutils-8.32.tar.xz 　下载后软件包存放在“downloads”目录中。\n　以下是本次制作所用到的软件包源码的地址：\nAcl: https://download.savannah.gnu.org/releases/acl/acl-2.3.1.tar.xz\nAttr: https://download.savannah.gnu.org/releases/attr/attr-2.5.1.tar.gz\nAutoconf: https://ftp.gnu.org/gnu/autoconf/autoconf-2.71.tar.xz\nAutomake: https://ftp.gnu.org/gnu/automake/automake-1.16.3.tar.xz\nBash: https://ftp.gnu.org/gnu/bash/bash-5.1.tar.gz\nBC: https://github.com/gavinhoward/bc/releases/download/4.0.2/bc-4.0.2.tar.xz\nBinutils: 暂无下载\nBison: https://ftp.gnu.org/gnu/bison/bison-3.7.6.tar.xz\nBzip2: https://www.sourceware.org/pub/bzip2/bzip2-1.0.8.tar.gz\nCoreutils: https://ftp.gnu.org/gnu/coreutils/coreutils-8.32.tar.xz\nD-Bus: https://dbus.freedesktop.org/releases/dbus/dbus-1.12.20.tar.gz\nDiffutils: https://ftp.gnu.org/gnu/diffutils/diffutils-3.7.tar.xz\nE2fsprogs: https://downloads.sourceforge.net/project/e2fsprogs/e2fsprogs/v1.46.2/e2fsprogs-1.46.2.tar.gz\nExpat: https://prdownloads.sourceforge.net/expat/expat-2.4.1.tar.xz\nFile: https://astron.com/pub/file/file-5.40.tar.gz\nFindutils: https://ftp.gnu.org/gnu/findutils/findutils-4.8.0.tar.xz\nFlex: https://github.com/westes/flex/releases/download/v2.6.4/flex-2.6.4.tar.gz\nGawk: https://ftp.gnu.org/gnu/gawk/gawk-5.1.0.tar.xz\nGCC: 暂无下载\nGDBM: https://ftp.gnu.org/gnu/gdbm/gdbm-1.19.tar.gz\nGettext: https://ftp.gnu.org/gnu/gettext/gettext-0.21.tar.xz\nGlibc: 暂无下载\nGMP: https://ftp.gnu.org/gnu/gmp/gmp-6.2.1.tar.xz\nGPerf: https://ftp.gnu.org/gnu/gperf/gperf-3.1.tar.gz\nGrep: https://ftp.gnu.org/gnu/grep/grep-3.6.tar.xz\nGroff: https://ftp.gnu.org/gnu/groff/groff-1.22.4.tar.gz\nGrub2: https://github.com/loongarch64/grub/tree/dev-la64\nGzip: https://ftp.gnu.org/gnu/gzip/gzip-1.10.tar.xz\nIana-Etc: https://github.com/Mic92/iana-etc/releases/download/20210526/iana-etc-20210526.tar.gz\nIPRoute2: https://www.kernel.org/pub/linux/utils/net/iproute2/iproute2-5.12.0.tar.xz\nKBD: https://www.kernel.org/pub/linux/utils/kbd/kbd-2.4.0.tar.xz\nKmod: https://www.kernel.org/pub/linux/utils/kernel/kmod/kmod-29.tar.xz\nLess: https://www.greenwoodsoftware.com/less/less-581.tar.gz\nLibcap: https://www.kernel.org/pub/linux/libs/security/linux-privs/libcap2/libcap-2.50.tar.xz\nLibelf: https://sourceware.org/ftp/elfutils/0.185/elfutils-0.185.tar.bz2\nLibffi: https://sourceware.org/pub/libffi/libffi-3.3.tar.gz\nLibpipeline: https://download.savannah.gnu.org/releases/libpipeline/libpipeline-1.5.3.tar.gz\nLibtool: https://ftp.gnu.org/gnu/libtool/libtool-2.4.6.tar.xz\nLinux: https://github.com/loongson/linux/tree/loongarch-next\nLinux-Firmware: https://mirrors.edge.kernel.org/pub/linux/kernel/firmware/linux-firmware-20210511.tar.xz\nM4: https://ftp.gnu.org/gnu/m4/m4-1.4.18.tar.xz\nMake: https://ftp.gnu.org/gnu/make/make-4.3.tar.gz\nMan-DB: https://download.savannah.gnu.org/releases/man-db/man-db-2.9.4.tar.xz\nMan-Pages: https://www.kernel.org/pub/linux/docs/man-pages/man-pages-5.11.tar.xz\nMPC: https://ftp.gnu.org/gnu/mpc/mpc-1.2.1.tar.gz\nMPFR: https://www.mpfr.org/mpfr-4.1.0/mpfr-4.1.0.tar.xz\nNcurses: https://ftp.gnu.org/gnu/ncurses/ncurses-6.2.tar.gz\nNinja: https://github.com/ninja-build/ninja/archive/v1.10.2/ninja-1.10.2.tar.gz\nOpenSSL: https://www.openssl.org/source/openssl-1.1.1k.tar.gz\nPatch: https://ftp.gnu.org/gnu/patch/patch-2.7.6.tar.xz\nPkg-Config: https://pkg-config.freedesktop.org/releases/pkg-config-0.29.2.tar.gz\nProcps-NG: https://sourceforge.net/projects/procps-ng/files/Production/procps-ng-3.3.17.tar.xz\nPSmisc: https://sourceforge.net/projects/psmisc/files/psmisc/psmisc-23.4.tar.xz\nReadline: https://ftp.gnu.org/gnu/readline/readline-8.1.tar.gz\nSed: https://ftp.gnu.org/gnu/sed/sed-4.8.tar.xz\nShadow: https://github.com/shadow-maint/shadow/releases/download/4.8.1/shadow-4.8.1.tar.xz\nSystemd: https://github.com/systemd/systemd/archive/v248/systemd-248.tar.gz\nTar: https://ftp.gnu.org/gnu/tar/tar-1.34.tar.xz\nTexinfo: https://ftp.gnu.org/gnu/texinfo/texinfo-6.7.tar.xz\nUtil-Linux: https://www.kernel.org/pub/linux/utils/util-linux/v2.36/util-linux-2.36.2.tar.xz\nVIM: https://github.com/vim/vim/archive/refs/tags/v8.2.2879.tar.gz\nXZ: https://tukaani.org/xz/xz-5.2.5.tar.xz\nZlib: https://zlib.net/zlib-1.2.11.tar.xz\nZstd: https://github.com/facebook/zstd/releases/download/v1.5.0/zstd-1.5.0.tar.gz\n以下是本次制作所需补丁文件的下载地址：\nhttps://github.com/sunhaiyong1978/CLFS-for-LoongArch/blob/main/patches/automake-1.16.3-add-loongarch.patch\nhttps://github.com/sunhaiyong1978/CLFS-for-LoongArch/blob/main/patches/gcc-8-loongarch-fix-libdir.patch\nhttps://github.com/sunhaiyong1978/CLFS-for-LoongArch/blob/main/patches/glibc-2.28-fix-loongarch_pr_uid_and_pr_gid.patch\nhttps://github.com/sunhaiyong1978/CLFS-for-LoongArch/blob/main/patches/kbd-2.4.0-backspace-1.patch\nhttps://github.com/sunhaiyong1978/CLFS-for-LoongArch/blob/main/patches/libffi-3.3-add-loongarch.patch\nhttps://github.com/sunhaiyong1978/CLFS-for-LoongArch/blob/main/patches/systemd-248-add-loongarch64.patch\n　都下载完成后，离开\u0026quot;downloads\u0026quot;目录:\npopd 3 制作交叉工具链及相关工具 　接下来就正式进入交叉工具链和相关工具的制作环节。\n3.1 Linux内核头文件  代码准备  　Linux内核需要进行扩充式移植的软件包，在没有软件官方支持的情况下需要专门的获取代码的方式进行，以下是获取方式：\ngit clone https://github.com/loongson/linux.git -b loongarch-next --depth 1 pushd linux git archive --format=tar --output ../linux-5.13.0.tar \u0026#34;loongarch-next\u0026#34; popd mkdir linux-5.13.0 pushd linux-5.13.0 tar xvf ../linux-5.13.0.tar popd tar -czf ${DOWNLOADDIR}/linux-5.13.0.tar.gz linux-5.13.0  制作步骤  　按以下步骤制作Linux内核头文件并安装到目标系统目录中。\ntar xvf ${DOWNLOADDIR}/linux-5.13.0.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/linux-5.13.0 make mrproper make ARCH=loongarch INSTALL_HDR_PATH=dest headers_install find dest/include -name \u0026#39;.*\u0026#39; -delete mkdir -pv ${SYSDIR}/sysroot/usr/include cp -rv dest/include/* ${SYSDIR}/sysroot/usr/include popd 3.2 交叉编译器之Binutils  代码准备  　Binutils需要进行扩充式移植的软件包，在没有软件官方支持的情况下需要专门的获取代码的方式进行，以下是获取方式：\n略  制作步骤  　按以下步骤制作交叉编译工具链中的Binutils并安装到存放交叉工具链的目录中。\ntar xvf ${DOWNLOADDIR}/binutils-2.31.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/binutils-2.31 rm -rf gdb libdecnumber readline sim mkdir build cd build CC=gcc AR=ar AS=as \\ \t../configure --prefix=${SYSDIR}/cross-tools --build=${CROSS_HOST} --host=${CROSS_HOST} \\ \t--target=${CROSS_TARGET} --with-sysroot=${SYSDIR}/sysroot --disable-nls \\ \t--disable-static --disable-werror --enable-64-bit-bfd make configure-host make make install cp -v ../include/libiberty.h ${SYSDIR}/sysroot/usr/include popd 3.3 GMP 　制作交叉工具链中所使用的GMP软件包。\ntar xvf ${DOWNLOADDIR}/gmp-6.2.1.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/gmp-6.2.1 ./configure --prefix=${SYSDIR}/cross-tools --enable-cxx --disable-static make make install popd 3.4 MPFR 　制作交叉工具链中所使用的MPFR软件包。\ntar xvf ${DOWNLOADDIR}/mpfr-4.1.0.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/mpfr-4.1.0 ./configure --prefix=${SYSDIR}/cross-tools --disable-static --with-gmp=${SYSDIR}/cross-tools make make install popd 3.5 MPC 　制作交叉工具链中所使用的MPC软件包。\ntar xvf ${DOWNLOADDIR}/mpc-1.2.1.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/mpc-1.2.1 ./configure --prefix=${SYSDIR}/cross-tools --disable-static --with-gmp=${SYSDIR}/cross-tools make make install popd 3.6 交叉编译器之GCC（精简版）  代码准备  　GCC需要进行扩充式移植的软件包，在没有软件官方支持的情况下需要专门的获取代码的方式进行，以下是获取方式：\n略  制作步骤  　制作交叉编译器中的GCC，第一次编译交叉工具链的GCC需要采用精简方式进行编译和安装，否则会因为缺少目标系统的C库而导致部分内容编译链接失败，制作过程如下：\ntar xvf ${DOWNLOADDIR}/gcc-8.3.0.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/gcc-8.3.0 patch -Np1 -i ${DOWNLOADDIR}/gcc-8-loongarch-fix-libdir.patch mkdir build pushd build AR=ar LDFLAGS=\u0026#34;-Wl,-rpath,${SYSDIR}/cross-tools/lib\u0026#34; \\ \t../configure --prefix=${SYSDIR}/cross-tools --build=${CROSS_HOST} --host=${CROSS_HOST} \\ \t--target=${CROSS_TARGET} --disable-nls \\ \t--with-mpfr=${SYSDIR}/cross-tools --with-gmp=${SYSDIR}/cross-tools \\ \t--with-mpc=${SYSDIR}/cross-tools \\ \t--with-newlib --disable-shared --with-sysroot=${SYSDIR}/sysroot \\ \t--disable-decimal-float --disable-libgomp --disable-libitm \\ \t--disable-libsanitizer --disable-libquadmath --disable-threads \\ \t--disable-target-zlib \\ \t--with-system-zlib --enable-checking=release \\ \t--with-abi=${MABI} --with-fix-loongson3-llsc --with-arch=loongarch \\ \t--enable-languages=c --enable-tls make all-gcc all-target-libgcc make install-gcc install-target-libgcc popd popd 　对于目标是LoongArch架构来说，目前有几个参数是需要特别注意的：\n --with-newlib，因为当前没有目标系统Glibc的支持，所以使用newlib来临时支援GCC的运行。 --disable-shared，使用newlib需要配合该参数。 --with-abi=${MABI}，转换过来就是\u0026ndash;with-abi=lp64，loongarch64使用的ABI名字为lp64。 --with-arch=loongarch，指定目标架构为LoongArch。 --enable-tls，该参数必须指定，否则可能在后续编译目标系统的Glibc上出现错误。 --enable-languages=c，这次仅编译C语言的支持就可以了，因为当前没有目标系统的Glibc，只能制作精简版。  3.7 目标系统的Glibc  代码准备  　Glibc需要进行扩充式移植的软件包，在没有软件官方支持的情况下需要专门的获取代码的方式进行，以下是获取方式：\n略  制作步骤  　在制作并安装好交叉工具链的Binutils、精简版的GCC以及Linux内核的头文件后就可以编译目标系统的Glibc了，制作和安装步骤如下：\ntar xvf ${DOWNLOADDIR}/glibc-2.28.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/glibc-2.28 patch -Np1 -i ${DOWNLOADDIR}/glibc-2.28-fix-loongarch_pr_uid_and_pr_gid.patch mkdir -v build-64 pushd build-64 BUILD_CC=\u0026#34;gcc\u0026#34; CC=\u0026#34;${CROSS_TARGET}-gcc ${BUILD64}\u0026#34; \\ \tCXX=\u0026#34;${CROSS_TARGET}-gcc ${BUILD64}\u0026#34; \\ \tAR=\u0026#34;${CROSS_TARGET}-ar\u0026#34; RANLIB=\u0026#34;${CROSS_TARGET}-ranlib\u0026#34; \\ \t../configure --prefix=/usr --host=${CROSS_TARGET} --build=${CROSS_HOST} \\ \t--libdir=/usr/lib64 --libexecdir=/usr/lib64/glibc --enable-add-ons \\ \t--with-tls --with-binutils=${SYSDIR}/cross-tools/bin \\ \t--with-headers=${SYSDIR}/sysroot/usr/include \\ \t--enable-obsolete-rpc --disable-werror make make DESTDIR=${SYSDIR}/sysroot install popd popd 　Glibc是目标系统的一部分，因此指定prefix等路径参数时是按照常规系统的路径进行设置的，所以必须在安装时指定DESTDIR来指定安装到存放目标系统的目录中。\n3.8 交叉编译器之GCC（完整版） 　完成目标系统的Glibc之后就可以着手制作交叉工具链中完整版的GCC了，制作步骤如下：\ntar xvf ${DOWNLOADDIR}/gcc-8.3.0.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/gcc-8.3.0 patch -Np1 -i ${DOWNLOADDIR}/gcc-8-loongarch-fix-libdir.patch mkdir build-all pushd build-all AR=ar LDFLAGS=\u0026#34;-Wl,-rpath,${SYSDIR}/cross-tools/lib\u0026#34; \\ \t../configure --prefix=${SYSDIR}/cross-tools --build=${CROSS_HOST} \\ \t--host=${CROSS_HOST} --target=${CROSS_TARGET} \\ \t--with-sysroot=${SYSDIR}/sysroot --with-mpfr=${SYSDIR}/cross-tools \\ \t--with-gmp=${SYSDIR}/cross-tools --with-mpc=${SYSDIR}/cross-tools \\ \t--enable-__cxa_atexit --enable-threads=posix --with-system-zlib \\ \t--enable-libstdcxx-time --enable-checking=release \\ \t--with-abi=${MABI} --with-arch=loongarch --enable-tls \\ \t--enable-languages=c,c++,fortran,objc,obj-c++,lto make make install popd popd 　在完成目标系统的Glibc之后就可以增加和修改一些编译参数了，主要是如下：\n 去掉了--with-newlib和--disable-shared，因为有Glibc，所以不再需要newlib了。 --enable-threads=posix,可以设置线程支持了。 --enable-languages=c,c++,fortran,objc,obj-c++,lto，可以支持更多的开发语言了。  3.9 File 　File软件包的官方最新版已经集成了LoongArch的支持，可以识别出LoongArch架构的二进制文件，因此制作时使用5.40以上的版本。\ntar xvf ${DOWNLOADDIR}/file-5.40.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/file-5.40 ./configure --prefix=${SYSDIR}/cross-tools make make install popd 3.10 Automake 　Automake软件包中提供了许多软件包集成用来生成Makefile文件的脚本，但该脚本目标尚未增加对LoongArch架构的支持，因此需要对软件包打补丁文件来增加支持，制作步骤如下：\ntar xvf ${DOWNLOADDIR}/automake-1.16.3.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/automake-1.16.3 patch -Np1 -i ${DOWNLOADDIR}/automake-1.16.3-add-loongarch.patch ./configure --prefix=${SYSDIR}/cross-tools make make install popd 　打上补丁并安装到交叉工具链的目录中，这样当后续有软件包需要更新脚本文件时就可以通过本次安装的Automake中的脚本文件来进行替换。\n3.11 Pkg-Config 　为了能在交叉编译目标系统的过程中使用目标系统中已经安装的“pc”文件，我们在交叉工具链的目录中安装一个专门用来从目标系统目录中的查询“pc”文件的pkg-config命令，制作过程如下：\ntar xvf ${DOWNLOADDIR}/pkg-config-0.29.2.tar.gz -C ${BUILDDIR}/ pushd ${BUILDDIR}/pkg-config-0.29.2 ./configure --prefix=${SYSDIR}/cross-tools \\ \t--with-pc_path=${SYSDIR}/sysroot/usr/lib64/pkgconfig:${SYSDIR}/sysroot/usr/share/pkgconfig \\ \t--program-prefix=${CROSS_TARGET}- --with-internal-glib --disable-host-tool make make install popd 3.12 Ninja tar xvf ${DOWNLOADDIR}/ninja-1.10.2.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/ninja-1.10.2 python3 configure.py --bootstrap install -vm755 ninja ${SYSDIR}/cross-tools/bin/ popd 3.13 Groff 　编译目标系统的过程中会对Groff版本有一定要求，因此在交叉工具链的目录中安装一个版本较新的Groff。\ntar xvf ${DOWNLOADDIR}/groff-1.22.4.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/groff-1.22.4 PAGE=A4 ./configure --prefix=${SYSDIR}/cross-tools make make install popd 3.14 Grub2 　为了在交叉编译的环境下可以制作生成LoongArch机器上使用的EFI启动文件，我们在交叉工具链目录中存放一个可以生成目标机器EFI的Grub软件包。\n 代码准备  　Grub2需要进行扩充式移植的软件包，在没有软件官方支持的情况下需要专门的获取代码的方式进行，以下是获取方式：\ngit clone -b \u0026#34;dev-la64\u0026#34; https://github.com/loongarch64/grub.git pushd grub git archive --format=tar --output ../grub-2.06.tar \u0026#34;dev-la64\u0026#34; ./bootstrap pushd gnulib git archive --format=tar --output ../../gnulib.tar HEAD popd popd mkdir grub-2.06 pushd grub-2.06 tar xvf ../grub-2.06.tar mkdir gnulib tar xvf ../gnulib.tar -C gnulib ./bootstrap popd tar -czf ${DOWNLOADDIR}/grub-2.06.tar.gz grub-2.06  制作步骤  tar -xvf ${DOWNLOADDIR}/grub-2.06.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/grub-2.06 mkdir build pushd build TARGET_CC=\u0026#34;${CROSS_TARGET}-gcc\u0026#34; \\ \t../configure --build=${CROSS_HOST} --host=${CROSS_HOST} \\ \t--target=${CROSS_TARGET} --prefix=${SYSDIR}/cross-tools \\ \t--program-transform-name=s,grub,${CROSS_TARGET}-grub, \\ \t--with-platform=efi --with-utils=host --disable-werror make make install popd popd 　本次制作的Grub命令可以运行在X86的Linux系统环境中但可以生成LoongArch机器上使用的EFI文件。\n4 制作目标系统 　交叉工具链及其相关的工具制作并安装完成后就可以继续制作目标系统了。\n4.1 软件包制作说明 架构测试脚本替换 　在制作目标系统的过程中会经常遇到configure阶段提示不识别loongarch64架构的字样，这通常是软件包自带的架构探测脚本没有增加对loongarch64架构的识别，因此需要去对该问题进行处理，处理的方式通常有两种：\n 删除配置脚本，然后通过automake命令自动将新的探测脚本加入到软件包中，具体的操作方式为：  rm config.guess config.sub automake --add-missing 　这里假定config.guess和config.sub两个脚本文件在软件包的第一级目录下，也可能是在build-aux之类的目录，找到文件并删除，然后使用automake命令的“\u0026ndash;add-missing”参数来运行，该参数会自动确认是否缺少探测架构的脚本，如果缺少会从Automake软件包安装的目录中复制过来，因automake运行的是我们在交叉工具链目录中的，所以已经增加了LoongArch架构的判断，这样软件包就可以正常运行了。\n2.直接替换文件，具体的操作方式为：\ncp ${SYSDIR}/sysroot/usr/share/automake-1.16/config.* config/ 　如果使用automake命令无法解决，可以直接复制Automake软件包安装的脚本文件，以我们安装的Automake-1.16版本为例，从${SYSDIR}/sysroot/usr/share/automake-1.16/中复制config开头的文件覆盖当前要编译的软件包中的同名文件即可，这里假定需要覆盖的文件在config目录中，也可能是在其它目录，可根据需要进行覆盖。\n　也可能一个软件包中有多个探测脚本，那么就需要全部进行覆盖。\n安装目标系统中的软件包 　目标系统中的软件包安装的时候都是按照根目录（“/”）来存放的，所以如果直接安装那么就会安装到主系统的目录中，这必然是不对的，所以我们在安装的时候增加“DESTDIR”参数指定一个目录，那么安装的文件将以该指定目录作为安装的根目录进行安装，当我们设置为目标系统存放的目录时，就可以避开与主系统的冲突也可以让安装的软件包以正常的目录结构进行安装。\n　在后续的制作过程中会看到大多数软件包都支持“DESTDIR”参数设置，但也有个别软件包不支持，这种情况下通常采用软件包支持的类似功能参数来解决。\n交叉编译软件包 　通常在带有configure配置脚本的软件包可以使用build、host参数来指定编译方式，当build和host相同时是本地编译，不同时就是交叉编译。\n　build参数可以理解为当前主系统所使用的架构系统信息，而host则是目标系统运行的架构系统信息，在本文中采用在x86的Linux系统中交叉编译LoongArch64架构的Linux系统，所以根据之前定义的环境变量，build指定为${CROSS_HOST}则代表了当前主系统，host指定为${CROSS_TARGET}则代表了要编译生成的目标架构系统。\n　由于是交叉编译，所以在软件包的配置阶段有可能探测的参数错误，这可能导致编译出来的软件包不匹配目标架构系统，这时可以采用指定部分探测参数的方式来解决，通常可以采用创建config.cache文件，然后将一些需要探测的参数和取值写入到该文件中，例如：\ncat \u0026gt; config.cache \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; ac_cv_func_mmap_fixed_mapped=yes ...... EOF 　然后在configure的参数中指定--cache-file=config.cache，这样就可以在探测这些参数时使用文件中设置的值而不是尝试去探测，这可以避免探测到错误的取值。\n编译目录 　多数软件包可以在软件包自己的“根目录”中进行配置和编译，但也有一些软件包会建议创建一个新的目录来配置和编译，对这些需要创建目录进行编译的软件包，我们通常采用在该软件目录下创建一个“build”开头的目录，并在该目录中进行编译，这样便于使用完软件包后的清理工作。\n4.2 软件包的制作 Man-Pages tar xvf ${DOWNLOADDIR}/man-pages-5.11.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/man-pages-5.11 make DESTDIR=${SYSDIR}/sysroot install popd 　Man-Pages软件包没有配置阶段，直接安装到目标系统的目录中即可。\nIana-Etc tar xvf ${DOWNLOADDIR}/iana-etc-20210407.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/iana-etc-20210407 cp services protocols ${SYSDIR}/sysroot/etc popd 　Iana-Etc软件包无需配置编译，只要将包含的文件复制到目标系统的目录中即可。\nGMP tar xvf ${DOWNLOADDIR}/gmp-6.2.1.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/gmp-6.2.1 rm config.guess config.sub automake --add-missing ./configure --build=${CROSS_HOST} --host=${CROSS_TARGET} \\  --prefix=/usr --libdir=/usr/lib64 --enable-cxx make make DESTDIR=${SYSDIR}/sysroot install rm -v ${SYSDIR}/sysroot/usr/lib64/lib{gmp,gmpxx}.la popd 　GMP软件包自带的探测架构脚本不支持LoongArch，因此删除探测脚本并用automake命令重新安装探测脚本。\nMPFR tar xvf ${DOWNLOADDIR}/mpfr-4.1.0.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/mpfr-4.1.0 ./configure --build=${CROSS_HOST} --host=${CROSS_TARGET} --prefix=/usr --libdir=/usr/lib64 make make DESTDIR=${SYSDIR}/sysroot install rm -v ${SYSDIR}/sysroot/usr/lib64/libmpfr.la popd MPC tar xvf ${DOWNLOADDIR}/mpc-1.2.1.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/mpc-1.2.1 rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing ./configure --build=${CROSS_HOST} --host=${CROSS_TARGET} --prefix=/usr --libdir=/usr/lib64 make make DESTDIR=${SYSDIR}/sysroot install rm -v ${SYSDIR}/sysroot/usr/lib64/libmpc.la popd Zlib tar xvf ${DOWNLOADDIR}/zlib-1.2.11.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/zlib-1.2.11 CC=\u0026#34;${CROSS_TARGET}-gcc\u0026#34; ./configure --prefix=/usr --libdir=/usr/lib64 make make DESTDIR=${SYSDIR}/sysroot install popd Binutils 　这次编译的Binutils是目标系统中使用的，在交叉编译阶段不会使用到它。\ntar xvf ${DOWNLOADDIR}/binutils-2.31.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/binutils-2.31 rm -rf gdb libdecnumber readline sim mkdir build pushd build ../configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --enable-shared --disable-werror \\ \t--with-system-zlib --enable-64-bit-bfd make tooldir=/usr make DESTDIR=${SYSDIR}/sysroot tooldir=/usr install popd popd GCC 　与上面编译的Binutils一样，这次编译的GCC也是在目标系统中使用的编译器，在交叉编译阶段不会使用到它，但是其提供的libgcc、libstdc++等库可以为后续软件包的编译提供链接用的库。\ntar xvf ${DOWNLOADDIR}/gcc-8.3.0.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/gcc-8.3.0 patch -Np1 -i ${DOWNLOADDIR}/gcc-8-loongarch-fix-libdir.patch mkdir build pushd build ../configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --target=${CROSS_TARGET} \\ \t--enable-__cxa_atexit --enable-threads=posix \\ \t--with-system-zlib --enable-libstdcxx-time \\ \t--enable-checking=release --enable-tls \\ \t--with-abi=lp64 --with-arch=loongarch \\ \t--enable-languages=c,c++,fortran,objc,obj-c++,lto make make DESTDIR=${SYSDIR}/sysroot install ln -sv /usr/bin/cpp ${SYSDIR}/sysroot/lib ln -sv gcc ${SYSDIR}/sysroot/usr/bin/cc popd popd 　因在目标系统中使用，所以编译的完整一些，将C、C++以及Fortran等语言的支持加上。\nBzip2 tar xvf ${DOWNLOADDIR}/bzip2-1.0.8.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/bzip2-1.0.8 sed -i.orig -e \u0026#34;/^all:/s/ test//\u0026#34; Makefile make CC=${CROSS_TARGET}-gcc -f Makefile-libbz2_so make clean make CC=${CROSS_TARGET}-gcc make PREFIX=${SYSDIR}/sysroot/usr install cp -v bzip2-shared ${SYSDIR}/sysroot/bin/bzip2 cp -av libbz2.so* ${SYSDIR}/sysroot/lib64 ln -sfv ../../lib64/libbz2.so.1.0 ${SYSDIR}/sysroot/usr/lib64/libbz2.so rm -v ${SYSDIR}/sysroot/usr/bin/{bunzip2,bzcat,bzip2} ln -sfv bzip2 ${SYSDIR}/sysroot/bin/bunzip2 ln -sfv bzip2 ${SYSDIR}/sysroot/bin/bzcat rm -fv ${SYSDIR}/sysroot/usr/lib/libbz2.a popd 　由于Bzip2软件包没有configure的配置脚本，因此在编译的时候直接给make命令指定CC参数，该参数用来设置编译程序时使用的编译器命令名，这里设置了交叉编译器的命令名，使得接下来的编译采用交叉编译器进行。\n　安装Bzip2软件包时因没有DESTDIR参数用来设置安装根目录，所以在PREFIX参数中加入目标系统存放目录的路径。\nXZ tar xvf ${DOWNLOADDIR}/xz-5.2.5.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/xz-5.2.5 ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Zstd tar xvf ${DOWNLOADDIR}/zstd-1.5.0.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/zstd-1.5.0 make CC=\u0026#34;${CROSS_TARGET}-gcc\u0026#34; PREFIX=/usr LIBDIR=/usr/lib64 make CC=\u0026#34;${CROSS_TARGET}-gcc\u0026#34; PREFIX=/usr LIBDIR=/usr/lib64 DESTDIR=${SYSDIR}/sysroot install popd File tar xvf ${DOWNLOADDIR}/file-5.40.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/file-5.40 rm config.{sub,guess} automake --add-missing ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Ncurses tar xvf ${DOWNLOADDIR}/ncurses-6.2.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/ncurses-6.2 rm config.{sub,guess} automake --add-missing ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --with-shared --without-debug \\ \t--without-normal --enable-pc-files \\ \t--with-pkg-config-libdir=/usr/lib64/pkgconfig --enable-widec \\ \t--disable-stripping make make DESTDIR=${SYSDIR}/sysroot install for lib in ncurses form panel menu ; do rm -vf ${SYSDIR}/sysroot/usr/lib64/lib${lib}.so echo \u0026#34;INPUT(-l${lib}w)\u0026#34; \u0026gt; ${SYSDIR}/sysroot/usr/lib64/lib${lib}.so ln -sfv ${lib}w.pc ${SYSDIR}/sysroot/usr/lib64/pkgconfig/${lib}.pc done rm -vf ${SYSDIR}/sysroot/usr/lib64/libcursesw.so echo \u0026#34;INPUT(-lncursesw)\u0026#34; \u0026gt; ${SYSDIR}/sysroot/usr/lib64/libcursesw.so ln -sfv libncurses.so ${SYSDIR}/sysroot/usr/lib64/libcurses.so rm -fv ${SYSDIR}/sysroot/usr/lib64/libncurses++w.a popd cp ${SYSDIR}/sysroot/usr/bin/ncursesw6-config ${SYSDIR}/cross-tools/bin/ sed -i \u0026#34;s@-L\\$libdir@@g\u0026#34; ${SYSDIR}/cross-tools/bin/ncursesw6-config 　在安装完目标系统的Ncurses后，复制了一个ncursesw6-config脚本命令到交叉编译目录中，这是因为后续编译一些软件包时会调用该命令来获取安装到目标系统中的Nucrses库链接信息，而如果主系统中的库与目标系统中的库链接不一致可能导致链接失败，因此提供一个可以正确链接信息的脚本是有效的解决方案。\nReadline tar xvf ${DOWNLOADDIR}/readline-8.1.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/readline-8.1 sed -i \u0026#39;/MV.*old/d\u0026#39; Makefile.in sed -i \u0026#39;/{OLDSUFF}/c:\u0026#39; support/shlib-install rm support/config.{sub,guess} automake --add-missing ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} --host=${CROSS_TARGET} \\ \t--disable-static --with-curses make SHLIB_LIBS=\u0026#34;-lncursesw\u0026#34; make SHLIB_LIBS=\u0026#34;-lncursesw\u0026#34; DESTDIR=${SYSDIR}/sysroot install popd 　因交叉编译的原因，Redaline的配置脚本无法正确的探测目标系统中安装的Ncurses软件包，因此在配置中加入--with-curses参数保证加入Ncurses的支持以及在编译阶段加入SHLIB_LIBS=\u0026quot;-lncursesw\u0026quot;以保证正确链接库文件。\nM4 tar xvf ${DOWNLOADDIR}/m4-1.4.18.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/m4-1.4.18 sed -i \u0026#39;s/IO_ftrylockfile/IO_EOF_SEEN/\u0026#39; lib/*.c echo \u0026#34;#define _IO_IN_BACKUP 0x100\u0026#34; \u0026gt;\u0026gt; lib/stdio-impl.h ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd BC tar xvf ${DOWNLOADDIR}/bc-4.0.2.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/bc-4.0.2 CC=\u0026#34;${CROSS_TARGET}-gcc\u0026#34; HOSTCC=\u0026#34;gcc\u0026#34; ./configure --prefix=/usr make make DESTDIR=${SYSDIR}/sysroot install popd Flex tar xvf ${DOWNLOADDIR}/flex-2.6.4.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/flex-2.6.4 ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --disable-static make make DESTDIR=${SYSDIR}/sysroot install ln -sv flex ${SYSDIR}/sysroot/usr/bin/lex popd Attr tar xvf ${DOWNLOADDIR}/attr-2.5.1.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/attr-2.5.1 ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --disable-static --sysconfdir=/etc make make DESTDIR=${SYSDIR}/sysroot install rm ${SYSDIR}/sysroot/usr/lib64/libattr.la popd Acl tar xvf ${DOWNLOADDIR}/acl-2.3.1.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/acl-2.3.1 rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --disable-static make make DESTDIR=${SYSDIR}/sysroot install rm ${SYSDIR}/sysroot/usr/lib64/libacl.la popd Libcap tar xvf ${DOWNLOADDIR}/libcap-2.49.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/libcap-2.49 make CROSS_COMPILE=\u0026#34;${CROSS_TARGET}-\u0026#34; BUILD_CC=\u0026#34;gcc\u0026#34; GOLANG=no prefix=/usr lib=lib64 make CROSS_COMPILE=\u0026#34;${CROSS_TARGET}-\u0026#34; BUILD_CC=\u0026#34;gcc\u0026#34; GOLANG=no prefix=/usr lib=lib64 \\ \tDESTDIR=${SYSDIR}/sysroot install popd 　因为该软件包没有配置脚本，所以直接在make命令上增加指定编译器的参数CROSS_COMPILE=\u0026quot;${CROSS_TARGET}-\u0026quot;，这里要注意CROSS_COMPILE指定的是交叉编译工具的前缀而不是具体命令名，这样在编译过程中各种编译、汇编和链接相关的命令都会自动加上这个指定的前缀。\n　另外在编译过程中会编译在主系统中运行的程序，这个时候不能使用交叉编译器编译，所以还需要指定BUILD_CC=\u0026quot;gcc\u0026quot;这个参数来保证编译这些要运行的程序使用的是本地编译器。\nShadow tar xvf ${DOWNLOADDIR}/shadow-4.8.1.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/shadow-4.8.1 sed -i \u0026#39;s/groups$(EXEEXT) //\u0026#39; src/Makefile.in find man -name Makefile.in -exec sed -i \u0026#39;s/groups\\.1 / /\u0026#39; {} \\; find man -name Makefile.in -exec sed -i \u0026#39;s/getspnam\\.3 / /\u0026#39; {} \\; find man -name Makefile.in -exec sed -i \u0026#39;s/passwd\\.5 / /\u0026#39; {} \\; sed -e \u0026#39;s:#ENCRYPT_METHOD DES:ENCRYPT_METHOD SHA512:\u0026#39; \\ \t-e \u0026#39;s:/var/spool/mail:/var/mail:\u0026#39; \\ \t-e \u0026#39;/PATH=/{s@/sbin:@@;s@/bin:@@}\u0026#39; \\ \t-i etc/login.defs sed -i \u0026#39;s/1000/999/\u0026#39; etc/useradd ./configure --sysconfdir=/etc --build=${CROSS_HOST} --host=${CROSS_TARGET} \\ \t--with-group-name-max-length=32 make make DESTDIR=${SYSDIR}/sysroot install sed -i \u0026#39;s/yes/no/\u0026#39; ${SYSDIR}/sysroot/etc/default/useradd popd 　该软件包修改了一些默认的设置，下面介绍以下主要修改的内容：\n　1、将用户密码的加密模式从DES改为SHA512，后者相对前者更难破解。\n　2、修改useradd创建用户默认的起始组编号，这个修改可改可不改，但无论改不改这个组编号对应的组都必须在目标系统中存在。\n　3、修改useradd命令创建用户时默认创建mail目录的设置，该目录目前已很少使用，所以修改为默认不创建。\nSed tar xvf ${DOWNLOADDIR}/sed-4.8.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/sed-4.8 rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd PSmisc tar xvf ${DOWNLOADDIR}/psmisc-23.4.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/psmisc-23.4 sed -i.orig \u0026#34;/rpl_malloc/d\u0026#34; configure sed -i.orig \u0026#34;/rpl_realloc/d\u0026#34; configure ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Gettext tar xvf ${DOWNLOADDIR}/gettext-0.21.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/gettext-0.21 for i in $(dirname $(find -name \u0026#34;config.sub\u0026#34;)) do rm ./$i/config.{sub,guess} pushd $(dirname ./$i) automake --add-missing popd done ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --disable-static \\ \t--with-libncurses-prefix=${SYSDIR}/sysroot make sed -i \u0026#34;/hello-c++-kde/d\u0026#34; gettext-tools/examples/Makefile make DESTDIR=${SYSDIR}/sysroot install popd 　Gettext软件包的源码中有多处探测架构的脚本，这些脚本在当前的版本中均不支持LoongArch架构，所以找到全部探测脚本并进行替换。\nBison tar xvf ${DOWNLOADDIR}/bison-3.7.6.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/bison-3.7.6 rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Grep tar xvf ${DOWNLOADDIR}/grep-3.6.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/grep-3.6 rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Bash tar xvf ${DOWNLOADDIR}/bash-5.1.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/bash-5.1 rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing cat \u0026gt; config.cache \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; ac_cv_func_mmap_fixed_mapped=yes ac_cv_func_strcoll_works=yes ac_cv_func_working_mktime=yes bash_cv_func_sigsetjmp=present bash_cv_getcwd_malloc=yes bash_cv_job_control_missing=present bash_cv_printf_a_format=yes bash_cv_sys_named_pipes=present bash_cv_ulimit_maxfds=yes bash_cv_under_sys_siglist=yes bash_cv_unusable_rtsigs=no gt_cv_int_divbyzero_sigfpe=yes EOF sed -i \u0026#39;/^bashline.o:.*shmbchar.h/a bashline.o: ${DEFDIR}/builtext.h\u0026#39; Makefile.in ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --without-bash-malloc \\ \t--with-installed-readline --cache-file=config.cache make make DESTDIR=${SYSDIR}/sysroot install popd 　Bash软件在交叉编译时的配置阶段会有大量的参数探测错误，需要我们手工指定这些参数的真实取值，创建一个文本文件，将这些参数的取值写进去，并在configure配置中增加--cache-file=config.cache参数（其中config.cache就是保存参数的文本文件名）。\nLibtool tar xvf ${DOWNLOADDIR}/libtool-2.4.6.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/libtool-2.4.6 ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd GDBM tar xvf ${DOWNLOADDIR}/gdbm-1.19.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/gdbm-1.19 ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --disable-static --enable-libgdbm-compat make make DESTDIR=${SYSDIR}/sysroot install popd GPerf tar xvf ${DOWNLOADDIR}/gperf-3.1.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/gperf-3.1 ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Expat tar xvf ${DOWNLOADDIR}/expat-2.3.0.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/expat-2.3.0 ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} --host=${CROSS_TARGET} \\ \t--disable-static make make DESTDIR=${SYSDIR}/sysroot install popd Autoconf tar xvf ${DOWNLOADDIR}/autoconf-2.71.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/autoconf-2.71 ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Automake tar xvf ${DOWNLOADDIR}/automake-1.16.3.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/automake-1.16.3 patch -Np1 -i ${DOWNLOADDIR}/automake-1.16.3-add-loongarch.patch ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd 　在交叉编译目录中我们安装了一个Automake软件包，该软件包提供了增加LoongArch支持的探测脚本，有很多软件都会需要用这些脚本来覆盖自己源代码中的脚本。\n　在制作的目标系统中当然也需要改其中的Automake软件包，也使其支持LoongArch，这样将来在目标系统中配置编译一些软件包时就可以使用上。\nKmod tar xvf ${DOWNLOADDIR}/kmod-28.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/kmod-28 rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing ./configure --prefix=/usr --libdir=/usr/lib64 --bindir=/bin \\ \t--sysconfdir=/etc --build=${CROSS_HOST} --host=${CROSS_TARGET} \\ \t--with-xz --with-zstd --with-zlib make make DESTDIR=${SYSDIR}/sysroot install for target in depmod insmod lsmod modinfo modprobe rmmod; do ln -sfv ../bin/kmod ${SYSDIR}/sysroot/sbin/$target done ln -sfv kmod ${SYSDIR}/sysroot/bin/lsmod popd Libelf tar xvf ${DOWNLOADDIR}/elfutils-0.183.tar.bz2 -C ${BUILDDIR} pushd ${BUILDDIR}/elfutils-0.183 LIBS=\u0026#34;-lpthread -llzma -lz -lbz2 -lzstd\u0026#34; \\ \t./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --disable-libdebuginfod --disable-debuginfod \\ \tac_cv_search_lzma_auto_decoder=-llzma ac_cv_search_ZSTD_decompress=-lzstd make make -C libelf DESTDIR=${SYSDIR}/sysroot install make -C libelf DESTDIR=${SYSDIR}/sysroot install-data popd 　该软件包使用交叉编译会有个别功能探测错误，使用指定参数和取值的方式来解决，该制作步骤上采用了另一种设置参数取值的方式，若要指定的参数数值不多的情况下可以直接在configure的参数中进行设置,如ac_cv_search_lzma_auto_decoder=-llzma和ac_cv_search_ZSTD_decompress=-lzstd这就是这种设置方式，也可以通过将这两个参数写到config.cache，然后通过--cache-file=config.cache来使用。\nLibffi tar xvf ${DOWNLOADDIR}/libffi-3.3.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/libffi-3.3 patch -Np1 -i ${DOWNLOADDIR}/libffi-3.3-add-loongarch.patch aclocal automake -fi ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --disable-static --with-gcc-arch=native make make DESTDIR=${SYSDIR}/sysroot install popd 　Libffi也是一个要增加架构支持的软件包，这里通过打补丁的方式加入LoongArch架构的支持。\nOpenSSL tar xvf ${DOWNLOADDIR}/openssl-1.1.1k.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/openssl-1.1.1k CC=\u0026#34;${CROSS_TARGET}-gcc\u0026#34; \\ \t./Configure --prefix=/usr --openssldir=/etc/ssl \\ \t--libdir=lib64 shared zlib linux-generic64 make sed -i \u0026#39;/INSTALL_LIBS/s/libcrypto.a libssl.a//\u0026#39; Makefile make DESTDIR=${SYSDIR}/sysroot install popd 　OpenSSL是一个十分重要的安全算法库，通常对不同的架构可以使用汇编对算法进行优化，但其也提供了通用的C实现，因此可以采用linux-generic64来指定用通用实现进行编译，当然通用实现的性能是相对较低的，在今后如果有了针对LoongArch64的优化支持则可以修改该参数来达到优化编译的目的。\nCoreutils tar xvf ${DOWNLOADDIR}/coreutils-8.32.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/coreutils-8.32 sed -i \u0026#34;s@SYS_getdents@SYS_getdents64@g\u0026#34; src/ls.c rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing FORCE_UNSAFE_CONFIGURE=1 \\ \t./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} \\ \t--enable-no-install-program=kill,uptime make make DESTDIR=${SYSDIR}/sysroot install mv -v ${SYSDIR}/sysroot/usr/bin/chroot ${SYSDIR}/sysroot/usr/sbin popd Diffutils tar xvf ${DOWNLOADDIR}/diffutils-3.7.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/diffutils-3.7 rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Gawk tar xvf ${DOWNLOADDIR}/gawk-5.1.0.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/gawk-5.1.0 sed -i \u0026#39;s/extras//\u0026#39; Makefile.in for i in $(dirname $(find -name \u0026#34;config.sub\u0026#34;)) do rm ./$i/config.{sub,guess} pushd $(dirname ./$i) automake --add-missing popd done ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Findutils tar xvf ${DOWNLOADDIR}/findutils-4.8.0.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/findutils-4.8.0 ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --localstatedir=/var/lib/locate make make DESTDIR=${SYSDIR}/sysroot install popd Groff tar xvf ${DOWNLOADDIR}/groff-1.22.4.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/groff-1.22.4 rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing PAGE=A4 ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} make TROFFBIN=troff GROFFBIN=groff GROFF_BIN_PATH= make DESTDIR=${SYSDIR}/sysroot install popd Less tar xvf ${DOWNLOADDIR}/less-581.2.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/less-581.2 ./configure --prefix=/usr --sysconfdir=/etc --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Gzip tar xvf ${DOWNLOADDIR}/gzip-1.10.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/gzip-1.10 rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd IPRoute2 tar xvf ${DOWNLOADDIR}/iproute2-5.12.0.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/iproute2-5.12.0 sed -i /ARPD/d Makefile rm -fv man/man8/arpd.8 sed -i \u0026#39;s/.m_ipt.o//\u0026#39; tc/Makefile make CC=\u0026#34;${CROSS_TARGET}-gcc\u0026#34; HOSTCC=\u0026#34;gcc\u0026#34; KERNEL_INCLUDE=${SYSDIR}/sysroot/usr/include make CC=\u0026#34;${CROSS_TARGET}-gcc\u0026#34; HOSTCC=\u0026#34;gcc\u0026#34; KERNEL_INCLUDE=${SYSDIR}/sysroot/usr/include \\ \tDESTDIR=${SYSDIR}/sysroot install popd 　IPRoute2软件包没有配置阶段，直接在make命令中使用“CC”变量指定交叉编译器，而对于在编译过程中会临时编译一些在本地运行的程序时就需要使用“HOSTCC”变量来指定本地编译器，否则“HOSTCC”会使用“CC”变量的指定编译器，那么编译出来的程序就无法在交叉编译的主系统中运行了。\nKBD tar xvf ${DOWNLOADDIR}/kbd-2.4.0.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/kbd-2.4.0 patch -Np1 -i ${DOWNLOADDIR}/kbd-2.4.0-backspace-1.patch sed -i \u0026#39;/RESIZECONS_PROGS=/s/yes/no/\u0026#39; configure sed -i \u0026#39;s/resizecons.8 //\u0026#39; docs/man/man8/Makefile.in rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing LIBS=\u0026#34;-lrt -lpthread\u0026#34; \\ \t./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} --disable-vlock make make DESTDIR=${SYSDIR}/sysroot install popd 　交叉编译KBD时可能会缺少链接库而导致制作失败，此时可以通过LIBS变量指定缺少链接的库而完成KBD软件包的制作。\nLibpipeline tar xvf ${DOWNLOADDIR}/libpipeline-1.5.3.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/libpipeline-1.5.3 rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Make tar xvf ${DOWNLOADDIR}/make-4.3.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/make-4.3 rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Patch tar xvf ${DOWNLOADDIR}/patch-2.7.6.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/patch-2.7.6 ./configure --prefix=/usr -build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Man-DB tar xvf ${DOWNLOADDIR}/man-db-2.9.4.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/man-db-2.9.4 rm $(dirname $(find -name \u0026#34;config.sub\u0026#34;))/config.{sub,guess} automake --add-missing LIBS=\u0026#34;-lpipeline\u0026#34; \\ \t./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --sysconfdir=/etc --disable-setuid \\ \t--enable-cache-owner=bin --with-browser=/usr/bin/lynx \\ \t--with-vgrind=/usr/bin/vgrind --with-grap=/usr/bin/grap make make DESTDIR=${SYSDIR}/sysroot install popd Tar tar xvf ${DOWNLOADDIR}/tar-1.34.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/tar-1.34 FORCE_UNSAFE_CONFIGURE=1 ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install popd Texinfo tar xvf ${DOWNLOADDIR}/texinfo-6.7.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/texinfo-6.7 for i in $(dirname $(find -name \u0026#34;config.sub\u0026#34;)) do rm ./$i/config.{sub,guess} pushd $(dirname ./$i) automake --add-missing popd done ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} make make DESTDIR=${SYSDIR}/sysroot install make DESTDIR=${SYSDIR}/sysroot TEXMF=/usr/share/texmf install-tex popd VIM tar xvf ${DOWNLOADDIR}/v8.2.2879.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/vim-8.2.2879 echo \u0026#39;#define SYS_VIMRC_FILE \u0026#34;/etc/vimrc\u0026#34;\u0026#39; \u0026gt;\u0026gt; src/feature.h cat \u0026gt; src/auto/config.cache \u0026lt;\u0026lt; EOF vim_cv_getcwd_broken=no vim_cv_toupper_broken=no vim_cv_terminfo=yes vim_cv_tgetent=zero vim_cv_stat_ignores_slash=no vim_cv_memmove_handles_overlap=yes EOF ./configure --prefix=/usr --build=${CROSS_HOST} --host=${CROSS_TARGET} --with-tlib=ncurses make make DESTDIR=${SYSDIR}/sysroot STRIP=${CROSS_TARGET}-strip install ln -sv vim ${SYSDIR}/sysroot/usr/bin/vi popd 　VIM制作过程中也需要设置一些参数避免自动探测错误，但VIM的参数设置文件是有默认文件路径的即“src/auto/config.cache”，在文件中写入参数和取值即可，configure配置脚本会自动从该文件中读取。\n　在安装完VIM后，我们可以配置VIM的默认设置文件，设置步骤如下：\ncat \u0026gt; ${SYSDIR}/sysroot/etc/vimrc \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; let skip_defaults_vim=1 set nocompatible set backspace=2 set mouse= syntax on if (\u0026amp;term == \u0026#34;xterm\u0026#34;) || (\u0026amp;term == \u0026#34;putty\u0026#34;) set background=dark endif EOF 　改设置内容主要是设置了一些基本的界面和操作特性，如Tab转换成几个空格显示，不同的终端下背景颜色等等。\nUtil-Linux tar xvf ${DOWNLOADDIR}/util-linux-2.36.2.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/util-linux-2.36.2 cp ${SYSDIR}/sysroot/usr/share/automake-1.16/config.* config/ LDFLAGS=\u0026#34;-lpthread\u0026#34; \\ \t./configure --build=${CROSS_HOST} --host=${CROSS_TARGET} \\  ADJTIME_PATH=/var/lib/hwclock/adjtime \\  --libdir=/usr/lib64 \\  --disable-chfn-chsh --disable-login --disable-nologin \\  --disable-su --disable-setpriv --disable-runuser \\  --disable-pylibmount --disable-static --without-python \\  --without-systemd --disable-makeinstall-chown \\  runstatedir=/run make make DESTDIR=${SYSDIR}/sysroot install popd 　Util-Linux带有大量的命令和库，由于部分命令已经在其它软件包中提供了，所以使用选项参数来关闭这些命令的编译和安装。\nSystemd 　Systemd采用的是meson命令进行配置阶段的操作，该命令与其他常见的configure脚本有明显的不同，所以在当前需要进行交叉编译的情况下也会采用完全不同的操作步骤，以下将展开进行说明。\ntar xvf ${DOWNLOADDIR}/systemd-248.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/systemd-248 patch -Np1 -i ${DOWNLOADDIR}/systemd-248-add-loongarch64.patch pushd src/basic python3 missing_syscalls.py missing_syscall_def.h $(ls syscalls-*.txt) popd sed -i \u0026#39;s/GROUP=\u0026#34;render\u0026#34;/GROUP=\u0026#34;video\u0026#34;/\u0026#39; rules.d/50-udev-default.rules.in 　以上步骤是为了解压Systemd源代码和打上支持LoongArch64的补丁，并且对代码进行必要的修正。\n　接下来的步骤是制作一个为meson命令用来交叉编译配置的文本文件，步骤如下：\necho \u0026#34;[binaries]\u0026#34; \u0026gt; meson-cross.txt echo \u0026#34;c = \u0026#39;${CROSS_TARGET}-gcc\u0026#39;\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo \u0026#34;cpp = \u0026#39;${CROSS_TARGET}-g++\u0026#39;\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo \u0026#34;ar = \u0026#39;${CROSS_TARGET}-ar\u0026#39;\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo \u0026#34;strip = \u0026#39;${CROSS_TARGET}-strip\u0026#39;\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo \u0026#34;pkgconfig = \u0026#39;${SYSDIR}/cross-tools/bin/${CROSS_TARGET}-pkg-config\u0026#39;\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo \u0026#34;[properties]\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo -n \u0026#34;c_args = [\u0026#39;\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo -n \u0026#34;${BUILD_ARCH}${BUILD_MABI}\u0026#34; | sed \u0026#34;s@ ?*@\u0026#39;,\u0026#39;@g\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo \u0026#34;\u0026#39;]\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo -n \u0026#34;cpp_args = [\u0026#39;\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo -n \u0026#34;${BUILD_ARCH}${BUILD_MABI}\u0026#34; | sed \u0026#34;s@ ?*@\u0026#39;,\u0026#39;@g\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo \u0026#34;\u0026#39;]\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo \u0026#34;c_link_args = [\u0026#39;-Wl,-rpath-link,/opt/mylaos/sysroot/usr/lib64\u0026#39;]\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo \u0026#34;cpp_link_args = [\u0026#39;-Wl,-rpath-link,/opt/mylaos/sysroot/usr/lib64\u0026#39;]\u0026#34; \u0026gt;\u0026gt; meson-cross.txt echo \u0026#34;sys_root = \u0026#39;${SYSDIR}/sysroot\u0026#39;\u0026#34; \u0026gt;\u0026gt; meson-cross.txt cat \u0026gt;\u0026gt; meson-cross.txt \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; [host_machine] system = \u0026#39;linux\u0026#39; cpu_family = \u0026#39;loongarch64\u0026#39; cpu = \u0026#39;loongarch64\u0026#39; endian = \u0026#39;little\u0026#39; EOF 　以上步骤完成后将在当前目录中生成一个meson-cross.txt文件，该文件包含了编译Systemd时目标架构的名字、系统、使用的工具链命令以及编译参数等等，这样在接下来的配置阶段中引用该文件就可以了。\n　以下是配置和编译的步骤：\nmkdir -p build pushd build LANG=en_US.UTF-8 \\ \tmeson --prefix=/usr --libdir=/usr/lib64 --sysconfdir=/etc --localstatedir=/var \\ \t-Dblkid=true -Dbuildtype=release -Ddefault-dnssec=no -Dfirstboot=false \\ \t-Dinstall-tests=false -Dldconfig=false -Dsysusers=false -Db_lto=false \\ \t-Drpmmacrosdir=no -Dhomed=false -Duserdb=false -Dman=false -Dmode=release \\ \t--cross-file ../meson-cross.txt \\ \t.. ninja DESTDIR=${SYSDIR}/sysroot ninja install popd popd 　较新版本的Systemd不再使用make命令进行编译了，配合meson使用ninja命令进行编译，在编译后同样用ninja命令安装软件包。\n　安装命令支持“DESTDIR”变量设置，但与make命令不同的是“DESTDIR”变量需要写在ninja命令的前面，安装的参数是“install”，该命令执行后同样将软件包安装到目标系统存放的目录中。\nD-Bus tar xvf ${DOWNLOADDIR}/dbus-1.12.20.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/dbus-1.12.20 ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --sysconfdir=/etc --localstatedir=/var \\ \t--disable-static --disable-doxygen-docs --disable-xml-docs \\ \t--with-console-auth-dir=/run/console \\ \t--with-system-pid-file=/run/dbus/pid \\ \t--with-system-socket=/run/dbus/system_bus_socket make make DESTDIR=${SYSDIR}/sysroot install ln -sfv /etc/machine-id ${SYSDIR}/sysroot/var/lib/dbus popd Procps-ng tar xvf ${DOWNLOADDIR}/procps-ng-3.3.17.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/procps-3.3.17 ./configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --disable-static --disable-kill \\ \t--with-systemd NCURSES_LIBS=\u0026#34;-lncursesw\u0026#34; \\ \tac_cv_func_malloc_0_nonnull=yes ac_cv_func_realloc_0_nonnull=yes make make DESTDIR=${SYSDIR}/sysroot install popd 　Procps-ng软件包也是在交叉编译方式上会出现参数判断错误的情况，需要在配置阶段指定参数和取值。\nE2fsprogs tar xvf ${DOWNLOADDIR}/e2fsprogs-1.46.2.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/e2fsprogs-1.46.2 cp ${SYSDIR}/sysroot/usr/share/automake-1.16/config.* config/ mkdir -v build pushd build LDFLAGS=\u0026#34;-Wl,-rpath-link,/opt/mylaos/sysroot/usr/lib64\u0026#34; \\ \t../configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} --sysconfdir=/etc \\ \t--enable-elf-shlibs--disable-libblkid \\ \t--disable-libuuid --disable-uuidd --disable-fsck make make DESTDIR=${SYSDIR}/sysroot install rm -fv ${SYSDIR}/sysroot/usr/lib64/{libcom_err,libe2p,libext2fs,libss}.a popd popd Linux tar xvf ${DOWNLOADDIR}/linux-5.13.0.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/linux-5.13.0 make mrproper make ARCH=loongarch CROSS_COMPILE=${CROSS_TARGET}- defconfig make ARCH=loongarch CROSS_COMPILE=${CROSS_TARGET}- menuconfig make ARCH=loongarch CROSS_COMPILE=${CROSS_TARGET}- make ARCH=loongarch CROSS_COMPILE=${CROSS_TARGET}- INSTALL_MOD_PATH=dest modules_install mkdir -pv ${SYSDIR}/sysroot/lib/modules/ cp -a dest/lib/modules/* ${SYSDIR}/sysroot/lib/modules/ cp -a vmlinux ${SYSDIR}/sysroot/boot/vmlinux popd 　因为是交叉编译的原因，Linux内核需要指定“ARCH”变量才能知道目标机器的架构，通过设置“CROSS_COMPILE”变量来指定命令前缀的方式来使用交叉编译工具的命令。\n　下面解释一下多个make命令步骤含义：\n　* defconfig，自动获取指定架构目录中的默认配置文件作为当前编译使用的配置文件。\n　* menuconfig，进入到交互式选择内核功能的界面，这需要主系统安装了Ncurses的开发库，该步骤可用来调整Linux内核选择，如果使用默认的就足够了，那么该步骤可以跳过。\n　* modules_install，安装模块文件，模块安装的根目录由INSTALL_MOD_PATH变量指定，这里指定了dest，代表安装到当前目录中的dest目录里，若没有该目录将自动创建。\n　当Linux内核编译完成后，我们可以将内核文件“vmlinux”和对应的模块复制到目标系统存放的目录中。\nLinux-Firmware tar xvf ${DOWNLOADDIR}/linux-firmware-20210511.tar.xz -C ${BUILDDIR} pushd ${BUILDDIR}/linux-firmware-20210511 make DESTDIR=${SYSDIR}/sysroot install popd 　安装Linux-Firmware软件包主要是因为当目标机器搭配了某些独显后需要相应的固件支持才能正常显示。\nGrub2 tar -xvf ${DOWNLOADDIR}/grub-2.06.tar.gz -C ${BUILDDIR} pushd ${BUILDDIR}/grub-2.06 mkdir build pushd build ../configure --prefix=/usr --libdir=/usr/lib64 --build=${CROSS_HOST} \\ \t--host=${CROSS_TARGET} -with-platform=efi \\ \t--with-utils=host --disable-werror make make DESTDIR=${SYSDIR}/sysroot install popd popd 　为目标系统安装Grub2的命令及模块，这样在启动目标架构机器上启动目标系统后也可以制作对应的EFI文件和设置启动相关的文件了。\n5 设置目标系统 　目标系统的软件包制作过程已经完成，接下来就是对目标系统进行必要的设置，以便目标系统可以正常的启动和使用。\n创建用户文件 　创建基本的用户名，这些用户名大多数在启动过程中会用到，步骤如下：\ncat \u0026gt; ${SYSDIR}/sysroot/etc/passwd \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; root::0:0:root:/root:/bin/bash bin❌1:1:bin:/dev/null:/bin/false daemon❌6:6:Daemon User:/dev/null:/bin/false messagebus❌18:18:D-Bus Message Daemon User:/var/run/dbus:/bin/false sshd❌50:50:sshd PrivSep:/var/lib/sshd:/bin/false systemd-bus-proxy❌72:72:systemd Bus Proxy:/:/bin/false systemd-journal-gateway❌73:73:systemd Journal Gateway:/:/bin/false systemd-journal-remote❌74:74:systemd Journal Remote:/:/bin/false systemd-journal-upload❌75:75:systemd Journal Upload:/:/bin/false systemd-network❌76:76:systemd Network Management:/:/bin/false systemd-resolve❌77:77:systemd Resolver:/:/bin/false systemd-timesync❌78:78:systemd Time Synchronization:/:/bin/false systemd-coredump❌79:79:systemd Core Dumper:/:/bin/false nobody❌99:99:Unprivileged User:/dev/null:/bin/false EOF\t创建组文件 　创建基本用户组，大多数都是系统必须的，步骤如下：\ncat \u0026gt; ${SYSDIR}/sysroot/etc/group \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; root❌0: bin❌1:daemon sys❌2: kmem❌3: tape❌4: tty❌5: daemon❌6: floppy❌7: disk❌8: lp❌9: dialout❌10: audio❌11: video❌12: utmp❌13: usb❌14: cdrom❌15: adm❌16: messagebus❌18: systemd-journal❌23: input❌24: mail❌34: sshd❌50: kvm❌61: systemd-bus-proxy❌72: systemd-journal-gateway❌73: systemd-journal-remote❌74: systemd-journal-upload❌75: systemd-network❌76: systemd-resolve❌77: systemd-timesync❌78: systemd-coredump❌79: saslauth❌81: wheel❌97: nogroup❌99: users❌999: EOF 创建输入配置文件 cat \u0026gt; ${SYSDIR}/sysroot/etc/inputrc \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; set horizontal-scroll-mode Off set meta-flag On set input-meta On set convert-meta Off set output-meta On set bell-style none \u0026#34;\\eOd\u0026#34;: backward-word \u0026#34;\\eOc\u0026#34;: forward-word \u0026#34;\\e[1~\u0026#34;: beginning-of-line \u0026#34;\\e[4~\u0026#34;: end-of-line \u0026#34;\\e[5~\u0026#34;: beginning-of-history \u0026#34;\\e[6~\u0026#34;: end-of-history \u0026#34;\\e[3~\u0026#34;: delete-char \u0026#34;\\e[2~\u0026#34;: quoted-insert \u0026#34;\\eOH\u0026#34;: beginning-of-line \u0026#34;\\eOF\u0026#34;: end-of-line \u0026#34;\\e[H\u0026#34;: beginning-of-line \u0026#34;\\e[F\u0026#34;: end-of-line EOF 　通过创建输入配置文件，可以使终端输入时更加符合常见系统中的习惯，不创建该文件也不会对系统造成影响。\n设置时间文件 cat \u0026gt; ${SYSDIR}/sysroot/etc/adjtime \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; 0.0 0 0.0 0 LOCAL EOF 　这里设置为使用BIOS提供的时间，如果使用UTC时间，可以将文件中的“LOCAL”改成“UTC”。\n创建系统信息文件 cat \u0026gt; ${SYSDIR}/sysroot/etc/lsb-release \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; DISTRIB_ID=\u0026#34;My GNU/Linux System for LoongArch64\u0026#34; DISTRIB_RELEASE=\u0026#34;1.0\u0026#34; DISTRIB_CODENAME=\u0026#34;Sun Haiyong\u0026#34; DISTRIB_DESCRIPTION=\u0026#34;My GNU/Linux System\u0026#34; EOF cat \u0026gt; ${SYSDIR}/sysroot/etc/os-release \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; NAME=\u0026#34;My GNU/Linux System for LoongArch64\u0026#34; VERSION=\u0026#34;1.0\u0026#34; ID=CLFS4LA64 PRETTY_NAME=\u0026#34;My GNU/Linux System for LoongArch64 1.0\u0026#34; VERSION_CODENAME=\u0026#34;Sun Haiyong\u0026#34; EOF 启动设置 生成EFI文件 　生成UEFI的启动文件，用于启动grub，命令如下：\n${CROSS_TARGET}-grub-mkimage \\  --directory \u0026#34;${SYSDIR}/sysroot/usr/lib64/grub/loongarch64-efi\u0026#34; \\  --prefix \u0026#39;(,gpt2)/boot/grub\u0026#39; \\  --output \u0026#34;${SYSDIR}/sysroot/boot/efi/EFI/BOOT/BOOTLOONGARCH.EFI\u0026#34; \\  --format \u0026#39;loongarch64-efi\u0026#39; \\  --compression \u0026#39;auto\u0026#39; \\  \u0026#39;ext2\u0026#39; \u0026#39;part_gpt\u0026#39; 　因为运行的是存放在交叉编译工具目录中的Grub命令，所以根据当时安装的命名规则运行的命令是以${CROSS_TARGET}-开头的。\n　解释一下上述命令的参数：\n  --directory，该参数指定生成EFI文件所使用模块存放的目录，这里指定的是目标系统存放目录中Grub安装的模块目录。\n  --prefix，该参数指定EFI文件读取文件的基础目录，也就是说EFI如果需要读取什么文件的话都以该参数设置的目录作为最基础的目录，这里有一个很重要的参数设置(,gpt2)，这指定的是存储设备的分区，括号中有两个参数，并使用“,”分隔，逗号前的参数是磁盘编号，逗号后的参数是分区编号，我们看到这里没有指定磁盘编号，那么EFI启动后会自动使用启动EFI文件的磁盘编号来代替，而分区编号指定为gpt2,其中“gpt”代表分区类型，这里通常为“gpt”或者“msdos”，“gpt”代表了GPT分区，“msdos”代表了DOS分区，目前GPT分区逐渐成为主流，且UEFI的BIOS也建议分区采用GPT，“gpt”后面的数字代表分区的编号，第一个分区为“1”，第二个分区为“2”，所以这里gpt2代表的是GPT的第二个分区。之所以这样设置是为了方便安装了目标系统的存储设备可以正常的启动，因为通常存放EFI文件的分区和存放与其匹配的Grub启动相关文件的分区都在同一个存储设备上。\n  --output，该参数指定生成的EFI文件存放的路径和文件名，这里设置的是目标系统存放目录中的“/boot/efi/EFI/BOOT”，这是按照一个系统被正常挂载后的目录结构，“/boot/efi”目录通常挂载的是第一个分区，也就是EFI分区，在该分区中通常要创建“EFI/BOOT”，因为UEFI的BIOS通常从这个分区的这个目录中载入EFI文件用于启动。“BOOTLOONGARCH.EFI”是LoongArch机器使用的默认查找的启动EFI文件名。\n  --format，该参数指定生成文件的格式名，不同架构以及不同启动方式的名字会不同，这里针对LoongArch64的EFI启动方式采用的名称为“loongarch64-efi”。\n  --compression 'auto'，该参数指定生成的EFI文件采用的压缩方式，这里设置为auto就可以了，其它的取值还有xz代表用XZ的压缩方式和none代表不进行压缩。\n  'ext2' 'part_gpt',这两个是指定加入到EFI文件中的模块，加入到EFI文件中的模块会自动作为EFI文件启动后能直接使用的功能，而如果没有加入到EFI中则需要通过加载模块的方式才能使用，这里只加入了ext2和part_gpt是因为模块都存放在存储设备中，如果要读取模块就需要能识别存储设备的分区和文件系统，这里part_gpt用来识别存储设备的GPT分区，而ext2则是该分区所使用的文件系统，当这两者与实际的分区和文件系统相匹配的情况下，后续再有什么功能上的需求都可以用加载模块的方式来使用了，这样可以最小化EFI文件的大小，可加快BIOS对EFI文件的加载速度。模块的存放位置由--prefix参数指定的基础目录决定，在这个基础目录中的loongarch64-efi目录就是存放各个模块的目录。\n  安装Grub模块文件 　生成好EFI文件后，就可以按照生成EFI所设置的目录存放Grub的模块文件了，安装过程如下：\nln -sfv . ${SYSDIR}/sysroot/boot/boot mkdir ${SYSDIR}/sysroot/boot/{grub,efi} mkdir -pv ${SYSDIR}/sysroot/boot/efi/EFI/BOOT cp -a ${SYSDIR}/sysroot/usr/lib64/grub/loongarch64-efi ${SYSDIR}/sysroot/boot/grub 6 处理目标系统 清理符号（symbol）信息 　目前安装到目标系统中的二进制文件大多带有各种符号信息，这些信息不影响执行，但是占用了大量的存储空间，如果没有调试相关的需求，可以将这些信息清理掉以减少存储空间。\n　清理符号信息可以使用strip命令，但strip必须能够处理目标平台二进制，所以我们可以使用交叉编译工具链中的strip命令来操作，操作步骤如下：\npushd ${SYSDIR}/sysroot find usr/lib{,64} -type f -name \\*.a -exec ${CROSS_TARGET}-strip --strip-debug {} \u0026#39;;\u0026#39; find usr/lib{,64} -type f -name \\*.so* -exec ${CROSS_TARGET}-strip --strip-unneeded {} \u0026#39;;\u0026#39; find usr/{bin,sbin,libexec} -type f -exec ${CROSS_TARGET}-strip --strip-all {} \u0026#39;;\u0026#39; popd 　这里我们发现strip使用的参数有多种，这里简单的说明一下：\n  --strip-debug，仅去掉调试相关的符号信息，该参数适合用于静态库文件，对于链接过程需要的信息是不会去掉的。\n  --strip-unneeded，删除所有与重定位无关的所有符号信息，该参数不能用于静态库文件，否则会导致静态链接时无法使用处理过的静态库。\n  --strip-all，该参数代表所有能去掉的符号信息都尽量去掉，该参数不建议用于库文件，特别是静态库文件。\n  打包系统 　制作完成后就可以退出制作用户环境了，使用命令:\nexit 　接着可以使用root权限对目标系统进行打包，打包步骤如下：\npushd ${SYSDIR}/sysroot sudo tar --xattrs-include=\u0026#39;*\u0026#39; --owner=root --group=root -cjpf \\ \t${SYSDIR}/loongarch64-clfs-system-1.0.tar.bz2 * popd 7 创建启动U盘 　制作好了目标系统后，我们可以尝试启动这个目标系统，借助U盘，我们来制作一个可以启动的简易LiveUSB。\n设置U盘分区 　找到一个容量不少于4G的U盘，如果没有进行符号清理，那么建议容量不少于8G，请确保U盘中没有重要和要保留的数据，因为接下来的操作将破坏U盘内原有的数据。\n　接着给U盘进行分区，建议划分为3个分区，分别是：\n　第一分区：EFI 分区，文件系统为fat，容量100M即可；\n　第二分区：boot分区，文件系统为ext2，容量500M即可；\n　第三分区：根分区，文件系统建议为xfs，剩余容量可以都分给该分区。\n　假设U盘设备名为sdb,以下为实际制作步骤如下：\nsudo cfdisk -z /dev/sdb 　该命令将出现交互式操作模式，-z参数将强制进入分区类型选择（这会导致U盘上原有数据全部丢失，请再次确认没有要保留的数据后再继续），这里选择gpt，然后在分区的界面中对U盘按照上述的分区进行，保存退出，此时系统中将有/dev/sdb1、/dev/sdb2和/dev/sdb3这三个分区名，接下来就开始处理这三个分区。\n　首先，创建一个目录用于制作LiveUSB，命令如下：\nmkdir /tmp/liveusb 　挂载U盘的第三个分区既根分区到该目录上，命令如下：\nsudo mount /dev/sdb3 /tmp/liveusb 　然后，创建一个boot分区，用于挂载第二分区既boot分区，命令如下：\nsudo mkdir /tmp/liveusb/boot sudo mount /dev/sdb2 /tmp/liveusb/boot 　接着创建efi分区，用于挂载第一分区既EFI分区，命令如下：\nsudo mkdir /tmp/liveusb/boot/efi sudo mount /dev/sdb1 /tmp/liveusb/boot/efi 　此时USB的分区挂载准备好了，接下来就是将目标系统解压到该目录即可，命令如下：\npushd /tmp/liveusb sudo tar -xvpf ${SYSDIR}/loongarch64-clfs-system-1.0.tar.bz2 popd 　解压完目标系统后先不要着急卸载和拔下U盘，因为还需要一些工作。\n制作Grub的启动菜单文件 　用Grub启动机器后通常会自动加载grub.cfg文件，用来显示启动菜单，以下就是制作一个简单的启动菜单制作步骤：\npushd /tmp/liveusb cat \u0026gt; boot/grub/grub.cfg \u0026lt;\u0026lt; \u0026#34;EOF\u0026#34; menuentry \u0026#39;My GNU/Linux System for LoongArch64\u0026#39; { echo \u0026#39;Loading Linux Kernel ...\u0026#39; linux /vmlinux root=\u0026lt;PARTUUID\u0026gt; rootdelay=5 rw boot } EOF popd 　grub.cfg存放的目录是由生成EFI文件时--prefix参数设置决定的，按照参数设置的目录并命名为grub.cfg即可。\n　下面简单介绍一下菜单文件的设置内容：\n  menuentry，该设置项设置启动菜单显示的条目，一个条目对应一个menuentry。\n  echo，输入内容，就是在屏幕上打印该行的内容。\n  linux，加载Linux内核，因当前加载的grub.cfg与Linux内核vmlinux文件在同一个分区，则可以直接使用路径，若不在同一个分区中则需要设置磁盘和分区来指定内核文件路径。后面的root=\u0026lt;PARTUUID\u0026gt; rootdelay=5 rw都是提供给Linux内核启动时的参数：root指定启动根分区名，这里设置了待转换的\u0026lt;PARTUUID\u0026gt;，接下来会用到，也可以时用确定的设备名，假定U盘的设备名是sdb，根分区是sdb3，则在可以写成root=/dev/sdb3，当然这里需要根据U盘插入到目标机器上时的设备名进行修改；rootdelay设置等待时间，这通常在用U盘作为启动盘时使用，因为U盘会需要一小段的初始化，如果没有等待会导致找不到设备而启动失败；rw设置根分区按照可读写的方式挂载。\n  　当设置根分区为待转换的\u0026lt;PARTUUID\u0026gt;时，就需要根据根分区的实际PARTUUID进行替换，替换步骤如下：\npushd /tmp/liveusb ROOTPARTUUID=$(sudo blkid /dev/sdb3 | awk -F\u0026#39;PARTUUID=\u0026#39; \u0026#39;{ print $2 }\u0026#39;) sed -i \u0026#34;s@\u0026lt;PARTUUID\u0026gt;@PARTUUID=${ROOTPARTUUID}@g\u0026#34; boot/grub/grub.cfg popd 　我们可以看到替换步骤就是通过blkid命令获取到实际分区的“PARTUUID”，“PARTUUID”通常是由5段字母和数字组成的32个字符的字符串，每段字符使用“-”进行链接，例如：b2c2bd57-82e4-1c25-b87a-0e9caf919053。\n　内核启动时可以通过给root参数传递“PARTUUID”的参数来查找根分区，这样可以使U盘具备更好的通用性。\n　做到这里，我们基本完成了LiveUSB的制作过程，接下来先卸载U盘：\nsudo umount -R /tmp/liveusb 　umount命令使用‵-R‵参数可以一次行把指定目录中多个挂载都卸载掉。\n　接下来就可以拔出U盘，然后到龙芯3A5000的机器上去启动一下试试吧。\n附录 参考资料 《用“芯”探索 教你构建龙芯平台的Linux系统》 孙海勇著\nLFS： https://www.linuxfromscratch.org/lfs/\n","permalink":"/zh-cn/docs/clfs_for_loongarch64/","series":null,"tags":null,"title":"手把手教你构建基于LoongArch64架构的Linux系统"},{"categories":[""],"content":"2021年一季度，上游社区陆续合并了file、meson、cmake的LoongArch补丁。\nmeson Meson（The Meson Build System）是个项目构建系统，语法设计简单、清晰、简洁，用户友好、编译速度快（使用ninja)，提供了更多现代特性，如单元测试（unit testing）、代码覆盖率报告（code coverage reporting）、头文件预编译（precompiled headers），交叉编译，众多语言和开发框架支持等，大量的社区项目已采用 meson 来做为构建系统。\n对LoongArch的支持补丁已提交 上游社区，从2月15日发布的 meson-0.57.0 版本开始已经默认支持LoongArch架构。\nfile file 是Linux/Unix 系统中的常用命令，用来识别文件类型，文件编码等信息。\nLoongArch架构的可执行文件，由于不被支持，因此查看文件类型时，会显示为 unknown arch。\n$ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, *unknown arch 0x102* version 1 (SYSV), dynamically linked, interpreter /lib64/ld.so.1, for GNU/Linux 4.15.0, BuildID[sha1]=6e2d68b5bdd6ac78429a85a13c89b52eba76fb3d, stripped Xiaotian Wu 提交的补丁 ，希望可以显示为 LoongArch:\n$ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, LoongArch, version 1 (SYSV), dynamically linked, interpreter /lib64/ld.so.1, for GNU/Linux 4.15.0, BuildID[sha1]=6e2d68b5bdd6ac78429a85a13c89b52eba76fb3d, stripped 而在 file 维护者参考上游 binutils-gdb 仓库做了一番id更新 操作之后，最终显示为 Loongson Loongarch：\n$ file /bin/ls /bin/ls: ELF 64-bit LSB pie executable, Loongson Loongarch, version 1 (SYSV), dynamically linked, interpreter /lib64/ld.so.1, for GNU/Linux 4.15.0, BuildID[sha1]=6e2d68b5bdd6ac78429a85a13c89b52eba76fb3d, stripped 3月31日发布的 file-40 版本已经支持LoongArch架构。\ncmake CMake是个一个开源的跨平台自动化构建系统，是用来管理软件构建的程序，不依赖于特定编译器，可支持多层目录、多个应用程序与多个库。\n对LoongArch的支持补丁 已提交 上游，预计最早将于 3.20.2 版本中对外发布。\n","permalink":"/zh-cn/posts/20210508-upstream-community/","series":null,"tags":["新闻"],"title":"2021年一季度社区动态"},{"categories":[""],"content":"2021年4月15日，龙芯小范围发布了指令集手册，以收集反馈意见。4月30日，龙芯正式发布了龙芯架构指令集手册V1.00。\n龙芯胡伟武在2020年8月参加CCF全国计算机体系结构学术年会时，曾披露龙芯将放弃MIPS架构，转向完全自主知识产权的LoongArch指令集，并做了《指令系统的自主与兼容》特邀报告 来介绍这一全新架构的设计思路。\n该设计增加了支持生产级应用的向量指令集，并且能够以二进制翻译的方式兼容MIPS/RISC-V/ARM/x86这几种指令集的Linux程序，并且翻译MIPS指令集时损耗非常小。\n核心态方面：硬件能够支持两级地址翻译，x86→LoongArch，虚地址→物理地址（通过改造内存快表TLB，做到两级虚地址映射以减少映射开销，以及减少指令使用/指令翻译开销，即X86虚地址直接翻译成龙芯物理地址），面积和延迟开销都不大；以及，地址空间、中断处理等方面支持OS跨主板和对升级后的CPU兼容；\n用户态方面：功能上针对MIPS、X86、ARM、RISC-V的特征，绝大多数指令可以做到1对1或1对2翻译；还包括对X86的EFLAGS支持、RISC-V的原子同步指令支持；以及，ABI方面支持X86/MIPS系统调用兼容，支持MIPS汇编码直接翻译成LoongArch二进制。\n为了完成这样的设计，龙芯架构定义了2500多条指令，但还预留了一半的一级指令槽，未来可以继续扩展。\n胡伟武在演讲中介绍，在翻译运行X86应用时，开源的QEMU仅能达到5%的性能，而龙芯架构现在超过60%，优化后的目标是80%；翻译安卓ARM应用时，可以流畅运行移动版WPS和美图秀秀等。\n龙芯此前使用的是MIPS指令集的授权，该授权允许龙芯自己修改，但不允许转授权，甚至不允许公布指令集手册，否则就将侵权。尽管龙芯已经是MIPS生态中性能最好的，但却仍然受制于人，不能自主引领生态。龙芯曾于2015年发布LoongISA指令集架构，该架构包括MIPS64 Release 2全套指令集和MIPS64 Release 5中的部分指令模块，以及其他一系列龙芯中科自主扩展的指令集。但由于从未公布过指令集手册，导致开发者实际上很难使用这些扩展指令集，这也是龙芯历年来在一系列性能测试中，官方发布的成绩总是不能由外界复现的原因。\n2021年4月，拥有MIPS指令集的Wave Computing公司投向RISC-V阵营。龙芯也终于开始正式脱离MIPS生态。此次发布的LoongArch指令集是完全自主知识产权的。为此，龙芯公司还委托国内第三方知名知识产权评估机构对龙芯基础架构进行深入细致的知识产权评估。从2020年二季度开始，双方投入上百人月，将LoongArch与ALPHA、ARM、MIPS、POWER、RISC-V、X86等国际上主要指令系统有关资料和几万件专利进行深入对比分析。2021年1月，针对被评估的基础架构版本，该评估机构认为：LoongArch在指令系统设计、指令格式、指令编码、寻址模式等方面进行了自主设计。LoongArch指令系统手册在章节结构、指令说明结构和指令内容表达方面与上述国际上主要指令系统存在明显区别。LoongArch基础架构未发现对上述国际上主要指令系统中国专利的侵权风险。\n2021年4月15日，龙芯小范围发布了指令集手册，以收集反馈意见。4月30日，龙芯正式发布了龙芯架构指令集手册V1.00 。\n龙芯架构采用基础部分加扩展部分的模块化组织形式。一个兼容龙芯架构的CPU，除实现必需的基础部分外，可根据实际需求选择实现各扩展部分。此次对外发布的《龙芯架构参考手册卷一：基础架构（V1.00）》 主要介绍龙芯架构中的基础部分。\n手册引言部分对龙芯架构进行了整体概述，介绍了指令编码格式、汇编助记格式等基本内容。手册的主体部分从非特权指令集和特权指令集两个方面对龙芯架构的基础部分展开描述，其中非特权指令集部分介绍了基础整数指令和基础浮点指令两类指令的应用程序编程模型、各指令的指令格式及其功能描述，特权指令集部分从特权资源整体架构、存储管理、例外与中断以及状态控制寄存器四个方面分别展开介绍。\n此次与《龙芯架构参考手册卷一：基础架构（V1.00）》 同步发布的有《龙芯架构32位精简版参考手册（V1.00）》 。龙芯架构32位精简版是对龙芯架构32位基础部分的进一步简化，必选指令条数仅50余条，易于实现，将面向教学和科研领域开源推广。\n","permalink":"/zh-cn/posts/20210501-loongarch-manual/","series":null,"tags":["新闻"],"title":"LoongArch指令集手册发布"},{"categories":[""],"content":"随着龙芯 3A5000 CPU 的研制成功，带来了新的 LoongArch 指令集，虽然这个全新的指令集自主化程度很高， 但同时也意味着没有任何的社区支持，没有任何软件可以直接支持，想要建设生态，一切需要从头开始， 这是一项艰巨、繁重而且需要长期坚持和投入的任务。\n所幸，龙芯已经充分认识到了这个问题，从 LoongArch 开始，将坚持 上游优先(upstream first) 策略， 以更加开放的心态，积极参与社区项目，完善软件生态。\n从社区的一些迹象来看，龙芯已经开始向上游合并补丁了，算是上游优先策略迈出了第一步。\nBinutils 2020年8月17日，Xu Chenghua 发出了第一封关于LoongArch的邮件 ，要求为龙芯保留 253~256 Machine numbers， 经过几轮沟通，最终上游将 258 分配给了 LoongArch 架构，并于 2020年12月13日正式合并到主分支。\nhttps://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=4cf2ad720078a9f490dd5b5bc8893a926479196e\nGNU Autotools GNU Autotools 是POSIX系统中重要的软件构建套件，它支持将自由软件构建和安装到正在运行的系统中。\n相信玩过 Linux 的人，都知道经典的Linux软件编译三步曲：\n./configure make make install 在 ./configure 阶段，Autotools 会扫描宿主机系统（即当前正在运行的计算机）以进行各种测试并完成默认设置。\n在测试过程中，有一项是系统架构测试，当在陌生的新架构中运行时，./configure 将报错并退出，导致无法完成软件编译。\n其中最关键的2个架构相关文件为：config.guess 和 config.sub。\nconfig.git GNU Autotools 套件中 config.guess 和config.sub，被独立维护在为 config.git 仓库。\n其他软件如gnulib、automake将不定期从这里获取，并合入自己的代码树中，最终上游开发者通过GNU Autotools打包后，这2个文件将进入tarballs中被发布。\nWu Xiaotian 提交了与LA架构相关的补丁，并于2020年12月22日被合并到 config.git 主分支。\nhttps://git.savannah.gnu.org/gitweb/?p=config.git;a=commitdiff;h=c8ddc8472f8efcadafc1ef53ca1d863415fddd5f\ngnulib gnulib 代码被大多数软件直接集成，如 coreutils、grub 等等，目前也已经从 config.git 拉取了相关补丁。\nhttps://git.savannah.gnu.org/gitweb/?p=gnulib.git;a=commitdiff;h=6f600ec73085df142211bf8505083dcdd59859bb\nhttps://git.savannah.gnu.org/gitweb/?p=gnulib.git;a=commitdiff;h=4c30b1b0d2ee72d89069b09f4257c30372c5b5a2\nautomake automake 更新较慢，相信下次拉取 config.git 代码后，也会进入主分支，预计1.18版本将会直接支持LoongArch架构。\nautomake 的历史版本，社区已经做了架构支持，并维护在以下分支，有需要的话可通过这里获取：\n1.16: https://github.com/loongarch64/automake/tree/la64/1.16\n1.16.1: https://github.com/loongarch64/automake/tree/la64/1.16.1\n1.16.2: https://github.com/loongarch64/automake/tree/la64/1.16.2\n1.16.3: https://github.com/loongarch64/automake/tree/la64/1.16.3\n虽然目前龙芯对于一些重量级的软件，如kernel、gcc、binutils、glibc、qemu等代码，还没有向上游发起合并， 但相信随着时间的推移，这些软件在准备就绪之后，也会很快合并到上游。\n要完善LoongArch生态，一个公司的人手和精力显然有限，希望感兴趣的社区爱好者可以参与，共同来建设LoongArch生态。\n","permalink":"/zh-cn/posts/20200127-binutils-and-autotools/","series":null,"tags":["新闻"],"title":"上游优先，迈出第一步"},{"categories":null,"content":"GNU汇编程序(as) 2.35版本的用户指南。\n本文档根据GNU自由文档许可证的条款分发。许可证的副本包含在标题为“ GNU自由文档许可证”的部分中。\n总览 这是有关如何调用as的简要概述。有关详细信息，请参见命令行选项。\nas [ -a [ cdghlns ][=file]] [ - alternate] [ -D ]\n[ - compress-debug-sections] [ - nocompress-debug-sections]\n[ - debug-prefix-map old=new]\n[ - defsym sym=val] [ -f ] [ -g ] [ - gstabs]\n[ - gstabs+] [ - gdwarf-] [ - gdwarf-sections]\n[ - gdwarf-cie-version=VERSION]\n[ - help] [ -I dir] [ -J ]\n[ -K ] [ -L ] [ - listing-lhs-width=NUM]\n[ - listing-lhs-width2=NUM] [ - listing-rhs-width=NUM]\n[ - listing-cont-lines=NUM] [ - keep-locals]\n[ - no-pad-sections]\n[ -o objfile] [ -R ]\n[ - hash-size=NUM] [ - reduce-memory-overheads]\n[ - statistics]\n[ -v ] [ -version ] [ - version]\n[ -W ] [ - warn] [ - fatal-warnings] [ -w ] [ -x ]\n[ -Z ] [ @ FILE]\n[ - sectname-subst] [ - size-check=[error|warning]]\n[ - elf-stt-common=[no|yes]]\n[ - generate-missing-build-notes=[no|yes]]\n[ - target-help] [target-options]\n[ - |files …]\nLoongarch 目标选项:\n[ -mabi =ABI]\n@file\nRead command-line options from FILE. The options read are inserted in place of the original @FILE option. If FILE does not exist, or cannot be read, then the option will be treated literally, and not removed. Options in FILE are separated by whitespace. A whitespace character may be included in an option by surrounding the entire option in either single or double quotes. Any character (including a backslash) may be included by prefixing the character to be included with a backslash. The FILE may itself contain additional @FILE options; any such options will be processed recursively. 从file中读取命令行选项。读取的选项将代替原始的@ file选项插入。 如果文件 不存在或无法读取，则该选项将按字面意义处理，并且不会删除。 文件中的选项用空格分隔。通过将整个选项括在单引号或双引号中，可以在选项中包括空格字符。 通过在要包含的字符前面加上反斜杠，可以包含任何字符（包括反斜杠）。 该文件本身可能包含其他@文件选项；任何此类选项将被递归处理。  -a[cdghlmns]\n打开清单输出列表。可以任意使用以下各种方法：  -ac\n忽略假(false)的条件  -ad\n忽略调试(debugging)指令  -ag\n包括一般(general)信息，例如版本和传递的选项  -ah\n包括高级(high-level)语言的源代码  -al\n包括汇编(assembly)代码  -am\n包括宏(macro)扩展  -an\n忽略格式(forms)处理过程  -as\n包含符号表(symbols)  =file\n设置清单文件的名称  您可以组合使用这些选项：例如，不经过格式(forms)处理的汇编代码清单使用 \u0026lsquo;-aln\u0026rsquo; 。\n如果要使用 =file 选项，它必须在最后一个位置。选项 -a 单独使用时，缺省含义是 -ahls。\n--alternate\nBegin in alternate macro mode. *Note '.altmacro': Altmacro. 从备用宏模式开始。请参阅 [`.altmacro`](Altmacro.html#Altmacro).  --compress-debug-sections\nCompress DWARF debug sections using zlib with SHF_COMPRESSED from the ELF ABI. The resulting object file may not be compatible with older linkers and object file utilities. Note if compression would make a given section _larger_ then it is not compressed. 使用zlib和ELF ABI的SHF_COMPRESSED压缩DWARF调试节。 生成的目标文件可能与较旧的链接器和目标文件实用程序不兼容。 注意，如果压缩会使给定的部分 _变大_，则它不会被压缩。  --compress-debug-sections=none\n--compress-debug-sections=zlib\n--compress-debug-sections=zlib-gnu\n--compress-debug-sections=zlib-gabi\nThese options control how DWARF debug sections are compressed. '--compress-debug-sections=none' is equivalent to '--nocompress-debug-sections'. '--compress-debug-sections=zlib' and '--compress-debug-sections=zlib-gabi' are equivalent to '--compress-debug-sections'. '--compress-debug-sections=zlib-gnu' compresses DWARF debug sections using zlib. The debug sections are renamed to begin with '.zdebug'. Note if compression would make a given section _larger_ then it is not compressed nor renamed. 这些选项控制DWARF调试节的压缩方式。 --compress-debug-sections=none 相当于 --nocompress-debug-sections。 --compress-debug-sections=zlib 和 --compress-debug-sections=zlib-gabi 相当于 --compress-debug-sections。 --compress-debug-sections=zlib-gnu使用zlib压缩DWARF调试部分。调试部分重命名为以 '.zdebug'。 请注意，如果压缩会使给定的部分 _变大_，则它不会被压缩或重命名。  --nocompress-debug-sections\nDo not compress DWARF debug sections. This is usually the default for all targets except the x86/x86_64, but a configure time option can be used to override this. 不要压缩DWARF调试部分。对于除 x86/x86_64 之外的所有目标， 这通常是默认设置，但是可以使用配置时的选项可以覆盖它。  -D\n忽略。接受此选项是为了使脚本与其他汇编程序的调用兼容。  --debug-prefix-map old=new\nWhen assembling files in directory 'OLD', record debugging information describing them as in 'NEW' instead. 当汇编源文件位于 'old' 目录中时，记录描述它们的调试信息，如同在 'new' 目录中一样。  --defsym sym=value\n在处理输入文件之前，将符号 sym 定义为 value 。 value 必须是整型常量。 与C语言中一样，前导字符 '0x' 表示十六进制值，前导字符 '0' 表示八进制值。 可通过使用 '.set' 伪操作在源文件中覆盖符号的值。  -f\n快速(fast)处理 --- 跳过空白和注释预处理（假定输入源文件是编译器的输出）。  -g\n--gen-debug\nGenerate debugging information for each assembler source line using whichever debug format is preferred by the target. This currently means either STABS, ECOFF or DWARF2. When the debug format is DWARF then a '.debug_info' and '.debug_line' section is only emitted when the assembly file doesn't generate one itself. 使用目标首选的任何调试格式为每个汇编程序源代码行生成调试信息。 当前这意味着STABS，ECOFF或DWARF2 调试格式之一。  --gstabs\n生成逐行的 stabs 格式调试信息。如果调试器可以处理这种格式的信息，则有助于汇编代码的调试。  --gstabs+\nGenerate stabs debugging information for each assembler line, with GNU extensions that probably only gdb can handle, and that could make other debuggers crash or refuse to read your program. This may help debugging assembler code. Currently the only GNU extension is the location of the current working directory at assembling time. 使用可能只有gdb可以处理的GNU扩展，为每个汇编器行生成stab调试信息， 这可能会使其他调试器崩溃或拒绝读取程序。这可能有助于调试汇编代码。 当前，唯一的GNU扩展名是组装时当前工作目录的位置。  --gdwarf-2\nGenerate DWARF2 debugging information for each assembler line. This may help debugging assembler code, if the debugger can handle it. Note--this option is only supported by some targets, not all of them. 为每个汇编器行生成DWARF2调试信息。如果调试器可以处理汇编代码，则这 可能有助于调试。注意-此选项仅受某些目标支持，而并非所有目标都支持。  --gdwarf-3\nThis option is the same as the '--gdwarf-2' option, except that it allows for the possibility of the generation of extra debug information as per version 3 of the DWARF specification. Note - enabling this option does not guarantee the generation of any extra infortmation, the choice to do so is on a per target basis. 此选项与 --gdwarf-2 选项相同，除了它允许根据DWARF规范的版本3生成额外 的调试信息。注意-启用此选项并不能保证会产生任何额外的激励，因此可以根据每个目标进行选择。  --gdwarf-4\nThis option is the same as the '--gdwarf-2' option, except that it allows for the possibility of the generation of extra debug information as per version 4 of the DWARF specification. Note - enabling this option does not guarantee the generation of any extra infortmation, the choice to do so is on a per target basis. 此选项与 --gdwarf-2 选项相同，除了它允许根据DWARF规范的版本4生成额外 的调试信息。注意-启用此选项并不能保证会产生任何额外的激励，因此可以根据每个目标进行选择。  --gdwarf-5\nThis option is the same as the '--gdwarf-2' option, except that it allows for the possibility of the generation of extra debug information as per version 5 of the DWARF specification. Note - enabling this option does not guarantee the generation of any extra infortmation, the choice to do so is on a per target basis. 此选项与 --gdwarf-2 选项相同，除了它允许根据DWARF规范的版本5生成额外的调试信息。 注意-启用此选项并不能保证会产生任何额外的激励，因此可以根据每个目标进行选择。  --gdwarf-sections\nInstead of creating a .debug_line section, create a series of .debug_line.FOO sections where FOO is the name of the corresponding code section. For example a code section called .TEXT.FUNC will have its dwarf line number information placed into a section called .DEBUG_LINE.TEXT.FUNC. If the code section is just called .TEXT then debug line section will still be called just .DEBUG_LINE without any suffix. 而不是创建.debug_line部分，而是创建一系列.debug_line.foo节，其中foo是相应代码节的名称。 例如，一个名为.text.func的代码段 会将其侏儒行号信息放入一个名为.debug_line.text.func的段中。 如果仅将代码段称为.text， 则调试行段仍将仅称为.debug_line，不带任何后缀。  --gdwarf-cie-version=version\nControl which version of DWARF Common Information Entries (CIEs) are produced. When this flag is not specificed the default is version 1, though some targets can modify this default. Other possible values for VERSION are 3 or 4. 控制生成哪个版本的DWARF公共信息条目（CIEs）。 未指定此标志时，默认值为版本1，尽管某些目标可以修改此默认值。 版本的其他可能值为3或4。  --size-check=error\n--size-check=warning\n针对无效的 ELF .size 指令发出错误或警告。  --elf-stt-common=no\n--elf-stt-common=yes\nThese options control whether the ELF assembler should generate common symbols with the 'STT_COMMON' type. The default can be controlled by a configure option '--enable-elf-stt-common'. 这些选项控制ELF汇编程序是否应使用 STT_COMMON 类型生成公共符号。 默认值可以由 --enable-elf-stt-common 配置选项控制。  --generate-missing-build-notes=yes\n--generate-missing-build-notes=no\nThese options control whether the ELF assembler should generate GNU Build attribute notes if none are present in the input sources. The default can be controlled by the '--enable-generate-build-notes' configure option. 如果输入源中是none，则这些选项控制ELF汇编器是否应生成GNU Build属性注释。 默认值可以由 --enable-generate-build-notes 配置选项。  --help\n打印命令行选项摘要并退出。  --target-help\n打印所有目标特定选项的摘要并退出。  -I dir\n将目录dir添加到.include指令的搜索列表中。  -J\n不要警告符号(signed)溢出。  -K\nIssue warnings when difference tables altered for long displacements. 当差值表更改为长位移时，发出警告。 长跳切换表时发出警告。  -L\n--keep-locals\nKeep (in the symbol table) local symbols. These symbols start with system- specific local label prefixes, typically '.L' for ELF systems or 'L' for traditional a.out systems. See [Symbol Names](Symbol-Names.html#Symbol-Names). 保留（符号表中的）局部符号。这些符号以系统特定的局部标签前缀开头。 通常在ELF格式中为为'.L'，传统的a.out格式中为'L'。请参见符号名称。  --listing-lhs-width=number\nSet the maximum width, in words, of the output data column for an assembler listing to number. 将汇编程序列表的输出数据列的最大宽度（以字为单位）设置为number。  --listing-lhs-width2=number\nSet the maximum width, in words, of the output data column for continuation lines in an assembler listing to number. 将汇编程序列表中连续行的输出数据列的最大宽度（以字为单位）设置为number。  --listing-rhs-width=number\nSet the maximum width of an input source line, as displayed in a listing, to number bytes. 将清单中显示的输入源行的最大宽度设置为 数字字节。  --listing-cont-lines=number\nSet the maximum number of lines printed in a listing for a single line of input to number \\+ 1. 将清单中单行输入的最大行数设置为number + 1。  --no-pad-sections\nStop the assembler for padding the ends of output sections to the alignment of that section. The default is to pad the sections, but this can waste space which might be needed on targets which have tight memory constraints. 停止汇编程序，以将输出节的末端填充到该节的对齐位置。默认设置是填充这些节，但这会浪费空间，而这对于具有严格内存限制的目标可能是必需的。  -o objfile\n指定输出的目标文件名。  -R\n将来自数据部分(data section)的代码放置(fold)到文本部分(text section)。  --hash-size=number\nSet the default size of GAS's hash tables to a prime number close to number. Increasing this value can reduce the length of time it takes the assembler to perform its tasks, at the expense of increasing the assembler's memory requirements. Similarly reducing this value can reduce the memory requirements at the expense of speed. 将GAS哈希表的默认大小设置为接近number的素 数。增加此值可以减少汇编程序执行任务所需的时间，但会增加汇编程序的内存要求。同样，减小此值可以减少内存需求，但会降低速度。  --reduce-memory-overheads\nThis option reduces GAS's memory requirements, at the expense of making the assembly processes slower. Currently this switch is a synonym for '\\--hash- size=4051', but in the future it may have other effects as well. 此选项降低了GAS的内存要求，但以使组装过程更慢为代价。目前，此开关是“--hash-size = 4051”，但将来也可能会产生其他影响。  --sectname-subst\nHonor substitution sequences in section names. See [`.section name`](Section.html#Section-Name-Substitutions). 部分名称中的荣誉替换顺序。请参阅。 .section name  --statistics\n打印汇编过程中使用的最大空间（字节）和总时间（秒）。  --strip-local-absolute\n从输出符号表中删除局部绝对符号。  -v\n-version\n打印as的版本。  --version\n打印as的版本并退出。  -W\n--no-warn\n禁止显示警告消息。  --fatal-warnings\n将警告视为错误。  --warn\n不要禁止警告消息或将其视为错误。  -w\n已被忽略。  -x\n已被忽略。  -Z\n即使发生错误也要生成目标文件。  -- | files …\n标准输入或要汇编的源文件。  以下选项，当配置 as 为 Loongarch 处理器时有效。\n略\u0026hellip;\n命令行选项 句法 节和重定位 符号 表达式 汇编程序指令 对象属性 Loongarch相关功能","permalink":"/zh-cn/docs/gas/","series":null,"tags":null,"title":"GNU 汇编"},{"categories":null,"content":"在2020年CCF全国计算机体系结构学术年会（ACA，Advanced Computer Architecture）上，胡伟武研究员首次提出了LoongArch自主指令集架构，龙芯3A5000 是第一款支持LoongArch指令集的CPU产品。\n本社区将围绕LoongArch指令集，完善Linux软件生态。\n","permalink":"/zh-cn/pages/about/","series":null,"tags":null,"title":"关于本站"},{"categories":[""],"content":"2020年8月13日上午10:30分，CCF全国计算机体系结构学术年会（ACA，Advanced Computer Architecture）上， 胡伟武研究员作了《指令系统的自主与兼容》报告。\n  报告主要内容展示 ","permalink":"/zh-cn/posts/20200820-ccf-aca/","series":null,"tags":["新闻"],"title":"指令系统的自主与兼容"},{"categories":[],"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code    Code Blocks Code block with backticks \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","permalink":"/zh-cn/posts/markdown-syntax/","series":["用户手册"],"tags":["Markdown","CSS","HTML"],"title":"Markdown Syntax Guide"}]