[[floating-point-exceptions]]
==== Floating-Point Exceptions

Floating-point exception means that when the floating-point processing unit cannot process the operand or the result of floating-point calculation in a conventional manner, the floating-point functional unit will generate a corresponding exception.

The basic floating-point instructions support five floating-point exceptions defined by IEEE 754-2008:

* **I**nexact (`I`)
* **U**nderflow (`U`)
* **O**verflow (`O`)
* **D**ivision by Zero (`Z`)
* **I**nvalid Operation (`V`)

Each bit of the Cause field in `FCSR0` corresponds to the above-mentioned exceptions.
After the execution of each floating-point instruction, the occurrence of its exception will be updated to the Cause field of `FCSR0`.

`FCSR0` also contains an enable bit (`Enables` field) for each floating-point exception.
The enable bit determines whether an exception generated by the floating-point processing unit will trigger an exception trap or set a status flag.
When a floating-point exception occurs, if its corresponding `Enable` bit is `1`, then a floating-point exception trap will be triggered; if its corresponding `Enable` bit is `0`, then the floating-point exception trap will not be triggered, but Set the corresponding position of the Flag field in `FCSR0` to `1`.

During the execution of a floating-point instruction, multiple floating-point exceptions can be generated at the same time.

When a floating-point exception is generated during the execution of a floating-point instruction but the floating-point exception is not triggered, the floating-point processing unit will generate a default result.
Different exceptions produce default results in different ways.
The table lists specific generation rules.

[[default-results-of-floating-point-exceptions]]
.Default results of floating-point exceptions
[%header,cols="3*1,6"]
|===
|Area
|Description
|Rounding mode
|Default result

|`I`
|**I**nexact
|Any mode
|The result after rounding or the result after overflow

.4+|`U`
.4+|**U**nderflow
|RNE
|The result after rounding may be `0`, subnormal, the normal number with the smallest absolute value (single-precision: `&#177;2^-126^`, double-precision: `&#177;2^-1022^`)

|RZ
|The result after rounding, may be `0`, subnormal

|RP
|The rounded result may be `0`, subnormal, the smallest positive normal number (single-precision: `+2^-126^`, double-precision: `+2^-1022^`)

|RM
|The rounded result may be `0`, subnormal, the largest negative normal number (single-precision: `-2^-126^`, double-precision: `-2^-1022^`)

.4+|`O`
.4+|**O**verflow
|RNE
|Set the result to `+&#8734;` or `-&#8734;` according to the sign of the intermediate result

|RZ
|Set the result to the maximum number according to the sign of the intermediate result

|RP
|Correct negative overflow to the smallest negative number, and correct positive overflow to `+&#8734;`

|RM
|Correct the positive overflow to the largest positive number, and correct the negative overflow to `-&#8734;`

|`Z`
|Division by **Z**ero
|Any mode
|Provide a corresponding signed infinity number

|`V`
|In**V**alid Operation
|Any mode
|Provide a QNaN
|===

===== Illegal Operation Exception (`V`)

An invalid operation exception notification signal will be sent if and only if there is no valid defined result.
If no exception is triggered, a QNaN will be generated.
Please refer to <<characteristics-of-accessing-control-and-status-registers,Characteristics of Accessing Control and Status Registers>> of the IEEE 754-2008 specification for specific determination details of extraordinary operation exceptions.

If an exception is allowed to fall into: the result register is not modified, the source register remains.

If exceptions are prohibited from trapping: If no other exceptions occur, QNaN is written to the target register.

===== Division by Zero Exception (`Z`)

In the division operation, when the divisor is `0` and the dividend is-a limited non-zero data, the division by zero exception is signaled.

If an exception is allowed to fall into: the result register is not modified, the source register remains

If an exception is forbidden to fall into: if no trap occurs, the result is a signed infinite value.

===== Overflow Exception (`O`)

Regarding the exponent field as an unbounded rounding of the intermediate result, when the absolute value of the result obtained exceeds the maximum finite number of the target format, an overflow exception will be notified.(This exception sets both inexact exception and flag bit)

If an exception is allowed to fall into: the result register is not modified, the source register remains.

If exceptions are forbidden to fall into: If no trap occurs, the final result is determined by the rounding mode and the sign of the intermediate result.

===== Underflow Exception (`U`)

When the detection result is a small non-zero value, an underflow exception will occur.
The way to detect small non-zero values is to detect after rounding.
that is, for a non-zero result is in `(-2Emin, 2Emin)`, the result is considered to be a small non-zero value (Single-precision number `Emin=-126`, double-precision number `Emin=-1022`).
When `FCSR.Enable.U=0`, if the result is detected, a non-zero tiny value:

. If the final rounded result of the floating-point operation is inaccurate, both `U` and `I` in `FCSR.Cause` should be set to `1`;

. If the final rounded result of the floating-point operation is accurate, then `U` and `I` in `FCSR.Cause` are not set to `1`.

When `FCSR.Enable.U=1`, if the result is a non-zero tiny value, regardless of whether the final rounded result of the floating-point operation is accurate or inaccurate, it will trigger a floating-point exception trap.

===== Inexact Exception (`I`)

FPU generates inaccurate exceptions when the following situations occur:

* Rounding result is imprecise.

* The rounding result overflows, and the enable bit of the overflow exception is not set.

If an exception is allowed to fall: If an inexact exception trap is enabled, the result register is not modified and the source register is retained.
Because this execution mode affects performance, inaccurate exception traps are only enabled when necessary.

If an exception is prohibited, trapping is prohibited: If no other software trap occurs, the rounding or overflow result is sent to the destination register.
